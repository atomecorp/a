<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gooey Drag â€“ Parametrized (Color + Gradient, No Shadow)</title>
  <style>
    :root {
      /* ====== GLOBAL UI VARIABLES ====== */
      --tool-size: 63px;
      --tool-radius: 9px;
      --tool-radius-target: 100px;
      --tool-radius-transition: 3600ms cubic-bezier(0.22, 0.61, 0.36, 1);
      --icon-size: 28px;
      --label-color: #fff;
      --icon-color: #a93535;

      /* ====== GRADIENT (MORE COLOR) ====== */
      --grad-start: #a9d8ff;
      --grad-mid: #7fc3ff;
      --grad-end: #4aa8ff;
      --grad-angle-x1: 0%;
      --grad-angle-y1: 0%;
      --grad-angle-x2: 100%;
      --grad-angle-y2: 100%;

      /* ====== GOOEY ====== */
      --goo-blur: 12;
      /* higher = more goo */
      --goo-alpha-mul: 18;
      /* higher = harder edge + richer color */
      --goo-alpha-bias: -8;
      /* more negative = easier merge */

      /* ====== PHYSICS ====== */
      --spring: 0.15;
      --damp: 0.75;
      --drag-vel: 0.6;
      --snap-offset: +3;

      /* Layout */
      --label-pad-top: 6px;
      --label-pad-bottom: 10px;
    }

    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-family: system-ui
    }

    #scene {
      position: relative;
      width: 100%;
      height: 100%;
      background: url('https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?q=80&w=2200&auto=format&fit=crop') center/cover no-repeat;
    }

    #svgLayer {
      position: absolute;
      inset: 0;
      pointer-events: none
    }

    #uiLayer {
      position: absolute;
      inset: 0
    }

    .tool {
      position: absolute;
      width: var(--tool-size);
      height: var(--tool-size);
      border-radius: var(--tool-radius);
      background: transparent;
      color: var(--label-color);
      display: grid;
      grid-template-rows: 1fr;
      font-weight: 600;
      cursor: grab;
      user-select: none;
      touch-action: none;
      will-change: transform;
    }

    .tool .icon {
      display: grid;
      place-items: center;
      width: 100%;
      height: 100%;
    }

    .tool svg {
      width: var(--icon-size);
      height: var(--icon-size);
      fill: var(--icon-color);
      display: block;
    }

    .tool .label {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      text-align: center;
      margin: 0;
      padding: var(--label-pad-top) 0 var(--label-pad-bottom);
      line-height: 1.1;
    }
  </style>
</head>

<body>
  <div id="scene">

    <svg id="svgLayer" width="100%" height="100%" aria-hidden="true">
      <defs>
        <linearGradient id="gradUI">
          <stop offset="0%" stop-color="var(--grad-start)" />
          <stop offset="60%" stop-color="var(--grad-mid)" />
          <stop offset="100%" stop-color="var(--grad-end)" />
        </linearGradient>

        <!-- Gooey body only (no shadow). Numeric params are applied via JS for reliability. -->
        <filter id="goo" x="-80%" y="-80%" width="260%" height="260%">
          <feGaussianBlur id="gooBlur" in="SourceGraphic" stdDeviation="12" result="blur" />
          <feColorMatrix id="gooMatrix" in="blur" type="matrix" result="solid" values="1 0 0 0 0
                  0 1 0 0 0
                  0 0 1 0 0
                  0 0 0 18 -8" />
          <feComposite in="solid" in2="SourceGraphic" operator="over" result="gooBody" />
          <!-- Shadow layer -->
          <feDropShadow dx="0" dy="6" stdDeviation="10" flood-color="#000" flood-opacity="0.35" />
        </filter>
      </defs>
      <g id="gooGroup" filter="url(#goo)"></g>
    </svg>

    <div id="uiLayer"></div>
  </div>

  <script>
    const ROOT = document.documentElement;
    const CSS = getComputedStyle(ROOT);
    const DEBUG = false;
    const assert = DEBUG ? console.assert.bind(console) : () => { };

    // ====== Read CSS vars safely ======
    const readNum = (name, fallback) => {
      const v = parseFloat(CSS.getPropertyValue(name));
      return Number.isFinite(v) ? v : fallback;
    };
    const readStr = (name, fallback) => {
      const v = CSS.getPropertyValue(name).trim();
      return v || fallback;
    };
    const readMs = (name, fallbackMs) => {
      const v = CSS.getPropertyValue(name).trim();
      if (!v) return fallbackMs;
      const m = v.match(/([\d.]+)\s*(ms|s)?/i);
      if (!m) return fallbackMs;
      const n = parseFloat(m[1]);
      if (!Number.isFinite(n)) return fallbackMs;
      return m[2] && m[2].toLowerCase() === 's' ? n * 1000 : n;
    };

    // ====== Apply SVG numeric params (SVG filter primitives don't reliably accept CSS vars in numeric fields) ======
    function applySvgParams() {
      const blur = document.getElementById('gooBlur');
      const mat = document.getElementById('gooMatrix');
      const grad = document.getElementById('gradUI');

      assert(blur && mat && grad, 'Missing SVG filter/gradient nodes');

      // Gradient direction
      grad.setAttribute('x1', readStr('--grad-angle-x1', '0%'));
      grad.setAttribute('y1', readStr('--grad-angle-y1', '0%'));
      grad.setAttribute('x2', readStr('--grad-angle-x2', '100%'));
      grad.setAttribute('y2', readStr('--grad-angle-y2', '100%'));

      // Gooey params
      const gooBlur = readNum('--goo-blur', 12);
      const mul = readNum('--goo-alpha-mul', 18);
      const bias = readNum('--goo-alpha-bias', -8);

      blur.setAttribute('stdDeviation', String(gooBlur));
      mat.setAttribute('values',
        `1 0 0 0 0\n` +
        `0 1 0 0 0\n` +
        `0 0 1 0 0\n` +
        `0 0 0 ${mul} ${bias}`
      );
    }

    applySvgParams();

    // ====== PHYSICS ======
    const SPRING = readNum('--spring', 0.15);
    const DAMP = readNum('--damp', 0.75);
    const DRAG_VEL = readNum('--drag-vel', 0.6);
    const TOOL_SIZE = readNum('--tool-size', 120);
    const TOOL_HALF = TOOL_SIZE / 2;
    const TOOL_RADIUS = readNum('--tool-radius', 12);
    const TOOL_RADIUS_TARGET = readNum('--tool-radius-target', TOOL_RADIUS);
    const TOOL_RADIUS_TRANSITION_MS = readMs('--tool-radius-transition', 200);
    const EPS = 0.05;
    const SNAP_OFFSET = readNum('--snap-offset', 0);
    const ICON_VIEWBOX = 24;
    const ICON_CENTER = ICON_VIEWBOX / 2;

    const SNAP_IN = TOOL_SIZE * (140 / 120);
    const MERGE_IN = TOOL_SIZE * (80 / 120);
    const SNAP_GAP = TOOL_SIZE + SNAP_OFFSET;
    const SNAP_IN2 = SNAP_IN * SNAP_IN;
    const MERGE_IN2 = MERGE_IN * MERGE_IN;
    const CONTACT_EPS = Math.max(2, TOOL_SIZE * 0.05);
    const CONTACT_DIST = Math.max(0, SNAP_GAP) + CONTACT_EPS;
    const CONTACT_DIST2 = CONTACT_DIST * CONTACT_DIST;
    const PROX_DIST = Math.max(0, SNAP_GAP) + TOOL_SIZE;
    const PROX_DIST2 = PROX_DIST * PROX_DIST;

    const data = [
      { x: 200, y: 200, label: 'A', svg: '<circle cx="12" cy="12" r="10"/>' },
      { x: 450, y: 260, label: 'B', svg: '<rect x="4" y="4" width="16" height="16" rx="4"/>' },
      { x: 700, y: 340, label: 'C', svg: '<polygon points="12,2 22,22 2,22"/>' }
    ];

    const svgGroup = document.getElementById('gooGroup');
    const ui = document.getElementById('uiLayer');

    // Tests (kept simple, non-invasive)
    assert(svgGroup, 'Missing #gooGroup');
    assert(ui, 'Missing #uiLayer');
    assert(Array.isArray(data) && data.length === 3, 'Expected data to have 3 tools');

    let items = [];
    let drag = null;
    let dx = 0, dy = 0;

    // Build the tool DOM safely (no duplicate definition)
    function makeToolDom(label, iconMarkupA, iconMarkupB = null) {
      const tool = document.createElement('div');
      tool.className = 'tool';

      const iconWrap = document.createElement('div');
      iconWrap.className = 'icon';

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', '0 0 24 24');
      svg.setAttribute('aria-hidden', 'true');

      const iconGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

      const g1 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g1.innerHTML = iconMarkupA;
      iconGroup.appendChild(g1);

      if (iconMarkupB) {
        const g2 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g2.setAttribute('opacity', '0.95');
        g2.innerHTML = iconMarkupB;
        iconGroup.appendChild(g2);
      }
      svg.appendChild(iconGroup);

      iconWrap.appendChild(svg);

      const labelDiv = document.createElement('div');
      labelDiv.className = 'label';
      labelDiv.textContent = label;

      tool.appendChild(iconWrap);
      tool.appendChild(labelDiv);

      // Center icon geometry inside the 24x24 viewBox (runs after DOM insertion)
      requestAnimationFrame(() => {
        try {
          if (!document.body.contains(svg)) return;
          const bb = iconGroup.getBBox();
          if (!bb.width || !bb.height) return;
          const dx = ICON_CENTER - (bb.x + (bb.width / 2));
          const dy = ICON_CENTER - (bb.y + (bb.height / 2));
          iconGroup.setAttribute('transform', `translate(${dx} ${dy})`);
        } catch (_) {
          // ignore getBBox issues on some engines while not painted
        }
      });

      return tool;
    }

    // Extra tests: makeToolDom should be a function and return a tool
    assert(typeof makeToolDom === 'function', 'makeToolDom must be defined once');
    const __t = makeToolDom('T', '<circle cx="12" cy="12" r="10"/>');
    assert(__t instanceof HTMLElement && __t.classList.contains('tool'), 'makeToolDom must return a .tool element');

    function createTool(d) {
      const shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      shape.setAttribute('width', TOOL_SIZE);
      shape.setAttribute('height', TOOL_SIZE);
      shape.setAttribute('rx', TOOL_RADIUS);
      shape.setAttribute('ry', TOOL_RADIUS);
      shape.setAttribute('fill', 'url(#gradUI)');
      svgGroup.appendChild(shape);

      const tool = makeToolDom(d.label, d.svg);
      ui.appendChild(tool);

      const it = {
        x: d.x,
        y: d.y,
        vx: 0,
        vy: 0,
        shape,
        tool,
        label: d.label,
        svgA: d.svg,
        svgB: null,
        radius: TOOL_RADIUS,
        radiusApplied: TOOL_RADIUS,
        radiusFrom: TOOL_RADIUS,
        radiusTo: TOOL_RADIUS,
        radiusStart: 0,
        radiusDur: 0
      };
      items.push(it);
      update(it);

      tool.addEventListener('pointerdown', (e) => {
        drag = it;
        dx = e.clientX - it.x;
        dy = e.clientY - it.y;
        tool.setPointerCapture(e.pointerId);
        schedule();
      }, { passive: true });

      tool.addEventListener('pointerup', () => { drag = null; schedule(); }, { passive: true });
      tool.addEventListener('pointercancel', () => { drag = null; schedule(); }, { passive: true });
    }

    function update(it) {
      it.shape.setAttribute('x', it.x);
      it.shape.setAttribute('y', it.y);
      it.tool.style.transform = `translate3d(${it.x}px,${it.y}px,0)`;
    }

    function removeItemDom(it) {
      it.tool.remove();
      it.shape.remove();
    }

    function setMergedUI(stationary, removed) {
      stationary.label = stationary.label + removed.label;
      stationary.svgB = removed.svgA;

      const newTool = makeToolDom(stationary.label, stationary.svgA, stationary.svgB);
      stationary.tool.replaceWith(newTool);
      stationary.tool = newTool;

      // Rebind pointer handlers
      newTool.addEventListener('pointerdown', (e) => {
        drag = stationary;
        dx = e.clientX - stationary.x;
        dy = e.clientY - stationary.y;
        newTool.setPointerCapture(e.pointerId);
        schedule();
      }, { passive: true });
      newTool.addEventListener('pointerup', () => { drag = null; schedule(); }, { passive: true });
      newTool.addEventListener('pointercancel', () => { drag = null; schedule(); }, { passive: true });
    }

    // Merge rule: keep the tool underneath (not dragged) fixed.
    function mergePair(a, b, indexToRemove) {
      const stationary = (drag === a) ? b : a;
      const removed = (stationary === a) ? b : a;

      stationary.vx = 0;
      stationary.vy = 0;

      setMergedUI(stationary, removed);
      removeItemDom(removed);
      items.splice(indexToRemove, 1);

      update(stationary);
      schedule();
    }

    function applySnap(a, b) {
      const dir = Math.sign(b.x - a.x) || 1;
      const tx = a.x + dir * SNAP_GAP;
      const ty = a.y;

      b.vx *= 0.5;
      b.vy *= 0.5;
      b.vx += (tx - b.x) * SPRING;
      b.vy += (ty - b.y) * SPRING;
    }

    function checkSnap() {
      let snapped = false;
      for (let i = 0; i < items.length; i++) {
        for (let j = i + 1; j < items.length; j++) {
          const a = items[i];
          const b = items[j];
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const d2 = (dx * dx) + (dy * dy);

          if (d2 < SNAP_IN2 && d2 > MERGE_IN2) {
            applySnap(a, b);
            snapped = true;
          }

          if (d2 <= MERGE_IN2) {
            // If you drag one onto another: keep the one underneath (not dragged)
            if (drag === a) {
              mergePair(a, b, i);
              i = Math.max(-1, i - 1);
              break;
            } else {
              mergePair(a, b, j);
              j--;
            }
            snapped = true;
          }
        }
      }
      return snapped;
    }

    function isContact(it) {
      const ax = it.x + TOOL_HALF;
      const ay = it.y + TOOL_HALF;
      for (const other of items) {
        if (other === it) continue;
        const bx = other.x + TOOL_HALF;
        const by = other.y + TOOL_HALF;
        const dx = ax - bx;
        const dy = ay - by;
        if ((dx * dx) + (dy * dy) <= CONTACT_DIST2) {
          return true;
        }
      }
      return false;
    }

    function isNear(it) {
      const ax = it.x + TOOL_HALF;
      const ay = it.y + TOOL_HALF;
      for (const other of items) {
        if (other === it) continue;
        const bx = other.x + TOOL_HALF;
        const by = other.y + TOOL_HALF;
        const dx = ax - bx;
        const dy = ay - by;
        if ((dx * dx) + (dy * dy) <= PROX_DIST2) {
          return true;
        }
      }
      return false;
    }

    function applyRadius(it) {
      if (Math.abs(it.radius - it.radiusApplied) > 0.01) {
        it.shape.setAttribute('rx', it.radius);
        it.shape.setAttribute('ry', it.radius);
        it.radiusApplied = it.radius;
      }
    }

    function setRadiusTarget(it, target, now) {
      if (it.radiusTo === target) return;
      it.radiusFrom = it.radius;
      it.radiusTo = target;
      it.radiusStart = now;
      it.radiusDur = Math.max(0, TOOL_RADIUS_TRANSITION_MS);
      if (it.radiusDur === 0) {
        it.radius = target;
        applyRadius(it);
      }
    }

    function updateRadius(it, now) {
      if (it.radiusDur === 0) {
        it.radius = it.radiusTo;
        applyRadius(it);
        return false;
      }
      const t = (now - it.radiusStart) / it.radiusDur;
      if (t >= 1) {
        it.radius = it.radiusTo;
        it.radiusDur = 0;
        applyRadius(it);
        return false;
      }
      const eased = t * (2 - t);
      it.radius = it.radiusFrom + ((it.radiusTo - it.radiusFrom) * eased);
      applyRadius(it);
      return true;
    }

    let rafId = 0;
    function schedule() {
      if (!rafId) {
        rafId = requestAnimationFrame(tick);
      }
    }

    function tick() {
      rafId = 0;
      let active = false;
      const now = performance.now();

      if (drag) active = true;

      for (const it of items) {
        if (it !== drag) {
          it.vx *= DAMP;
          it.vy *= DAMP;
          it.x += it.vx;
          it.y += it.vy;
          update(it);

          if (Math.abs(it.vx) + Math.abs(it.vy) > EPS) {
            active = true;
          }
        }
      }

      if (checkSnap()) {
        active = true;
      }

      for (const it of items) {
        const contact = isContact(it);
        const target = contact ? TOOL_RADIUS : ((it === drag || isNear(it)) ? TOOL_RADIUS_TARGET : TOOL_RADIUS);
        setRadiusTarget(it, target, now);
        if (updateRadius(it, now)) {
          active = true;
        }
      }

      if (active) {
        schedule();
      }
    }

    data.forEach(createTool);
    assert(items.length === 3, 'Expected 3 created items');

    // Additional test: circles exist
    assert(svgGroup.children.length === 3, 'Expected 3 SVG shapes');

    schedule();

    document.addEventListener('pointermove', (e) => {
      if (!drag) return;
      const nx = e.clientX - dx;
      const ny = e.clientY - dy;

      drag.vx = (nx - drag.x) * DRAG_VEL;
      drag.vy = (ny - drag.y) * DRAG_VEL;

      drag.x = nx;
      drag.y = ny;
      update(drag);
      schedule();
    }, { passive: true });

    document.addEventListener('pointerup', () => { drag = null; schedule(); }, { passive: true });

    // Optional: if you tweak CSS vars live, call applySvgParams() again.
    window.applySvgParams = applySvgParams;
  </script>
</body>

</html>