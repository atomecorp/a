<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horloge Minimaliste</title>
</head>

<body>
    <script>
        (function () {
            /*
             English API docs for atome_clock parameters:

             atome_clock(show, format, precision, size, handThickness, contour)

             - show: boolean - whether the clock canvas is visible (true = show, false = hide)
             - format: 'circular' (default) or 'digit' / 'digital' / 'text' (digital display)
             - precision: boolean - whether to display seconds (true = higher refresh rate)
             - size: number or string - canvas square size in pixels (e.g. 300 or '300' or '33px');
                 pass null or 'null' or 'auto' for full-window
             - handThickness: number (10..100) - proportion relative to base thickness; 25 = default/base,
                 10 = very thin, 100 = very thick
             - contour: false | 'line' | 'circle' (or boolean for backward compatibility)
                 - false: draw no contour markers
                 - 'line': draw small hour tick lines on the outer contour
                 - 'circle': draw a stroked circle on the outer contour

             Examples:
               atome_clock(true, 'circular', true, null, 25, 'line'); // visible circular with ticks
               atome_clock(false); // hide clock
               atome_clock(true, 'digital', false, '300px', 50, false); // visible digital, no contour
            */
            const b = document.body;
            b.style.cssText = 'margin:0;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center';

            let c = document.querySelector('#atome-clock-canvas');
            if (!c) {
                c = document.createElement('canvas');
                c.id = 'atome-clock-canvas';
                b.appendChild(c);
            }
            const x = c.getContext('2d');

            // internal state
            const state = {
                format: 'circular', // 'circular' or 'digit'
                precision: true,     // show seconds
                size: null,          // px square size for canvas (null = full window)
                // visibility flag: true = visible, false = hidden
                show: true,
                // handThickness proportion: 25 = default/base, 10 = very thin, 100 = very thick
                handThickness: 25,
                // contour on outer rim: false | 'line' | 'circle' (default 'line')
                contour: 'line',
                intervalId: null,
                resizeHandler: null
            };

            function clearTimers() {
                if (state.intervalId) {
                    clearInterval(state.intervalId);
                    state.intervalId = null;
                }
            }

            function applySizing() {
                if (state.size && Number(state.size) > 0) {
                    const s = Number(state.size);
                    c.width = s;
                    c.height = s;
                    c.style.width = s + 'px';
                    c.style.height = s + 'px';
                    // center in viewport
                    b.style.alignItems = 'center';
                    b.style.justifyContent = 'center';
                    if (state.resizeHandler) {
                        window.removeEventListener('resize', state.resizeHandler);
                        state.resizeHandler = null;
                    }
                } else {
                    // full window
                    const resize = () => {
                        c.width = innerWidth;
                        c.height = innerHeight;
                    };
                    resize();
                    if (!state.resizeHandler) {
                        state.resizeHandler = resize;
                        window.addEventListener('resize', state.resizeHandler);
                    }
                }
            }

            function render() {
                const w = c.width, h = c.height, s = Math.min(w, h), cx = w / 2, cy = h / 2;
                const d = new Date(), hr = d.getHours(), mn = d.getMinutes(), sc = d.getSeconds(), ms = d.getMilliseconds();

                x.fillStyle = '#000';
                x.fillRect(0, 0, w, h);

                if (state.format === 'digit') {
                    const t = `${hr.toString().padStart(2, '0')}:${mn.toString().padStart(2, '0')}${state.precision ? ':' + sc.toString().padStart(2, '0') : ''}`;
                    // font sizing: prefer size when given, otherwise relative to viewport
                    const fontSize = state.size ? Math.floor(state.size * 0.18) : Math.floor(s * 0.15);
                    x.font = `${fontSize}px monospace`;
                    x.fillStyle = '#fff';
                    x.textAlign = 'center';
                    x.textBaseline = 'middle';
                    x.fillText(t, cx, cy);
                } else {
                    // circular clock
                    const R = s * .35;

                    // determine thickness scale from handThickness proportion for contour
                    const contourScale = (state.handThickness && Number(state.handThickness) > 0) ? (Number(state.handThickness) / 25) : 1;
                    // draw contour according to state.contour:
                    // false -> none; 'line' -> small hour tick lines; 'circle' -> stroked outer circle; 'dots' -> small points
                    if (state.contour && state.contour !== false) {
                        const outer = R * 0.98;
                        // line thickness uses handThickness; tick length does NOT depend on handThickness
                        if (state.contour === 'line' || state.contour === 'lines' || state.contour === true) {
                            const tickLen = Math.max(2, Math.floor(s * 0.04));
                            const lineW = Math.max(1, Math.floor(s * 0.006 * Math.max(1, contourScale * 1.5)));
                            x.strokeStyle = '#888';
                            x.lineWidth = lineW;
                            x.lineCap = 'round';
                            for (let i = 0; i < 12; i++) {
                                const a = i * Math.PI / 6 - Math.PI / 2;
                                const sx = cx + Math.cos(a) * (outer - tickLen);
                                const sy = cy + Math.sin(a) * (outer - tickLen);
                                const ex = cx + Math.cos(a) * outer;
                                const ey = cy + Math.sin(a) * outer;
                                x.beginPath();
                                x.moveTo(sx, sy);
                                x.lineTo(ex, ey);
                                x.stroke();
                            }
                        } else if (state.contour === 'circle') {
                            const circleW = Math.max(1, Math.floor(s * 0.01 * Math.max(1, contourScale * 1.8)));
                            x.beginPath();
                            x.arc(cx, cy, outer, 0, Math.PI * 2);
                            x.strokeStyle = '#888';
                            x.lineWidth = circleW;
                            x.stroke();
                        } else if (state.contour === 'dots') {
                            const dotR = Math.max(1, Math.floor(s * 0.012 * Math.max(1, contourScale)));
                            const outerR = outer;
                            x.fillStyle = '#888';
                            for (let i = 0; i < 12; i++) {
                                const a = i * Math.PI / 6 - Math.PI / 2;
                                const dx = cx + Math.cos(a) * outerR;
                                const dy = cy + Math.sin(a) * outerR;
                                x.beginPath();
                                x.arc(dx, dy, dotR, 0, Math.PI * 2);
                                x.fill();
                            }
                        }
                    }

                    const dr = (a, l, wth) => {
                        x.beginPath();
                        x.moveTo(cx, cy);
                        x.lineTo(cx + Math.cos(a) * l, cy + Math.sin(a) * l);
                        x.strokeStyle = '#fff';
                        x.lineWidth = wth;
                        x.lineCap = 'round';
                        x.stroke();
                    };

                    // determine thickness scale from handThickness proportion
                    // increase the multiplier so max value (100) produces noticeably thicker hands
                    const scale = (state.handThickness && Number(state.handThickness) > 0) ? (Number(state.handThickness) / 25) * 3 : 1;
                    const baseHour = s * .012 * scale;
                    const baseMin = s * .008 * scale;
                    const baseSec = s * .004 * scale;

                    const secFrac = state.precision ? (sc + ms / 1000) : sc;
                    dr(((hr % 12) * 60 + mn) / 2 * Math.PI / 30 - Math.PI / 2, R * .5, baseHour);
                    dr((mn + secFrac / 60) * Math.PI / 30 - Math.PI / 2, R * .75, baseMin);
                    if (state.precision) dr((sc + ms / 1000) * Math.PI / 30 - Math.PI / 2, R * .85, baseSec);

                    x.beginPath();
                    x.arc(cx, cy, s * .015, 0, Math.PI * 2);
                    x.fillStyle = '#fff';
                    x.fill();
                }
            }

            function schedule() {
                clearTimers();
                const interval = state.precision ? 100 : 1000;
                // render immediately then schedule
                render();
                state.intervalId = setInterval(render, interval);
            }

            // Public API
            // New parameter order: show first (true = visible, false = hidden)
            function atome_clock(show = true, format = 'circular', precision = true, size = null, handThickness = 25, showDots = true) {
                // normalize format: accept 'digit', 'digital', 'text' => digit, otherwise circular
                const f = (typeof format === 'string') ? format.toLowerCase().trim() : '';
                state.format = (f === 'digit' || f === 'digital' || f === 'text') ? 'digit' : 'circular';

                state.precision = !!precision;

                // parse size: accept numbers, numeric strings, '33px', and 'null' string
                function parseSize(v) {
                    if (v === null || v === undefined) return null;
                    if (typeof v === 'number') return v > 0 ? v : null;
                    if (typeof v === 'string') {
                        const s = v.trim().toLowerCase();
                        if (s === '' || s === 'null' || s === 'auto') return null;
                        if (s.endsWith('px')) {
                            const n = parseFloat(s.slice(0, -2));
                            return isNaN(n) ? null : n;
                        }
                        const n = Number(s);
                        return isNaN(n) ? null : n;
                    }
                    return null;
                }

                state.size = parseSize(size);
                // show boolean: true => visible, false => hidden
                state.show = (show === true || show === 'true');
                // parse and clamp handThickness
                const ht = Number(handThickness);
                if (!isNaN(ht)) {
                    state.handThickness = Math.max(10, Math.min(100, ht));
                }
                // parse contour: accept false|'false' => false, 'line'|'lines'|'true' => 'line', 'circle' => 'circle', 'dots' => 'dots'
                function parseContour(v) {
                    if (v === false || v === 'false' || v === null || v === undefined) return false;
                    if (v === true || v === 'true') return 'line';
                    const s = String(v).trim().toLowerCase();
                    if (s === '' || s === 'null') return false;
                    if (s === 'line' || s === 'lines' || s === 'tick' || s === 'ticks') return 'line';
                    if (s === 'circle' || s === 'circ') return 'circle';
                    if (s === 'dots' || s === 'dot' || s === 'points') return 'dots';
                    return false;
                }

                state.contour = parseContour(showDots);

                // apply hide/show
                c.style.display = state.show ? 'block' : 'none';

                applySizing();
                schedule();
            }

            // expose globally
            window.atome_clock = atome_clock;



            atome_clock(true, 'circular', false, 33, 50, 'dots');
        })();
    </script>
</body>

</html>