#!/bin/zsh

echo "ğŸ§¹ Suppression AGGRESSIVE des console.log de test..."

# CrÃ©er un dossier de sauvegarde
backup_dir="console_backup_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$backup_dir"
echo "ğŸ“‹ Dossier de sauvegarde: $backup_dir"

total_removed=0
files_modified=0

# Fonction pour supprimer les console.log multi-lignes
remove_multiline_console_log() {
    local file="$1"
    local temp_file=$(mktemp)
    local inside_console_log=false
    local paren_count=0
    local removed_lines=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        # VÃ©rifier si on commence un console.log avec Ã©mojis OU mots-clÃ©s de test
        if [[ "$line" =~ console\.log.*[ğŸ”¥ğŸ§ªğŸ“ğŸ“„ğŸ’¾ğŸš€âœ…âŒğŸ›‘ğŸ—‘ï¸ğŸ§¹âš¡ğŸ‰âœ¨] ]] || \
           [[ "$line" =~ console\.log.*[Tt]est ]] || \
           [[ "$line" =~ console\.log.*[Dd]ebug ]] || \
           [[ "$line" =~ console\.log.*[Aa]rchitecture ]] || \
           [[ "$line" =~ console\.log.*[Pp]erformance ]] || \
           [[ "$line" =~ console\.log.*[Ss]erver ]] || \
           [[ "$line" =~ console\.log.*[Ss]hutting ]] || \
           [[ "$line" =~ console\.log.*[Rr]unning ]] || \
           [[ "$line" =~ console\.log.*[Ss]tarting ]] || \
           [[ "$line" =~ console\.log.*[Ee]ndpoint ]] || \
           [[ "$line" =~ console\.log.*[Cc]losed ]] || \
           [[ "$line" =~ console\.log.*[Aa]vailable ]] || \
           [[ "$line" =~ console\.log.*[Ss]aved ]] || \
           [[ "$line" =~ console\.log.*[Dd]eleted ]] || \
           [[ "$line" =~ console\.log.*[Cc]leaned ]] || \
           [[ "$line" =~ ^[[:space:]]*\/\/.*console\.log ]]; then
            
            inside_console_log=true
            
            # Compter les parenthÃ¨ses ouvertes et fermÃ©es dans cette ligne
            local open_parens=$(echo "$line" | tr -cd '(' | wc -c)
            local close_parens=$(echo "$line" | tr -cd ')' | wc -c)
            paren_count=$((open_parens - close_parens))
            
            ((removed_lines++))
            
            # Si les parenthÃ¨ses sont Ã©quilibrÃ©es dans cette ligne, on termine ici
            if [ $paren_count -le 0 ]; then
                inside_console_log=false
            fi
            continue
        fi
        
        # Si on est Ã  l'intÃ©rieur d'un console.log multi-ligne
        if [ "$inside_console_log" = true ]; then
            # Compter les parenthÃ¨ses dans cette ligne
            local open_parens=$(echo "$line" | tr -cd '(' | wc -c)
            local close_parens=$(echo "$line" | tr -cd ')' | wc -c)
            paren_count=$((paren_count + open_parens - close_parens))
            
            ((removed_lines++))
            
            # Si on a fermÃ© toutes les parenthÃ¨ses, on sort du console.log
            if [ $paren_count -le 0 ]; then
                inside_console_log=false
            fi
            continue
        fi
        
        # Sinon, garder la ligne
        echo "$line" >> "$temp_file"
        
    done < "$file"
    
    # Remplacer le fichier original si des changements ont Ã©tÃ© faits
    if [ $removed_lines -gt 0 ]; then
        mv "$temp_file" "$file"
    else
        rm "$temp_file"
    fi
    
    echo $removed_lines
}

# Fonction pour traiter un fichier
process_file() {
    local file="$1"
    local basename_file=$(basename "$file")
    
    echo "ğŸ” Traitement: $file"
    
    # CrÃ©er une sauvegarde
    cp "$file" "$backup_dir/${basename_file}.backup"
    
    # Compter les lignes avant modification
    local lines_before=$(wc -l < "$file")
    
    # Supprimer les console.log commentÃ©s simples
    sed -i '' '/^[[:space:]]*\/\/.*console\.\(log\|debug\|info\|table\|warn\)/d' "$file"
    
    # Supprimer les console.log multi-lignes de test/debug
    local multiline_removed=$(remove_multiline_console_log "$file")
    
    # Supprimer TOUS les console.log avec Ã©mojis
    sed -i '' '/console\.log.*ğŸ”¥/d' "$file"
    sed -i '' '/console\.log.*ğŸ§ª/d' "$file"
    sed -i '' '/console\.log.*ğŸ“/d' "$file"
    sed -i '' '/console\.log.*ğŸ“„/d' "$file"
    sed -i '' '/console\.log.*ğŸ’¾/d' "$file"
    sed -i '' '/console\.log.*ğŸš€/d' "$file"
    sed -i '' '/console\.log.*âœ…/d' "$file"
    sed -i '' '/console\.log.*âŒ/d' "$file"
    sed -i '' '/console\.log.*ğŸ›‘/d' "$file"
    sed -i '' '/console\.log.*ğŸ—‘ï¸/d' "$file"
    sed -i '' '/console\.log.*ğŸ§¹/d' "$file"
    sed -i '' '/console\.log.*âš¡/d' "$file"
    sed -i '' '/console\.log.*ğŸ‰/d' "$file"
    sed -i '' '/console\.log.*âœ¨/d' "$file"
    
    # Supprimer TOUS les console.log avec mots-clÃ©s (y compris serveur)
    sed -i '' '/console\.log.*[Tt]est/d' "$file"
    sed -i '' '/console\.log.*[Dd]ebug/d' "$file"
    sed -i '' '/console\.log.*[Aa]rchitecture/d' "$file"
    sed -i '' '/console\.log.*[Pp]erformance/d' "$file"
    sed -i '' '/console\.log.*[Ss]erver/d' "$file"
    sed -i '' '/console\.log.*[Ss]hutting/d' "$file"
    sed -i '' '/console\.log.*[Rr]unning/d' "$file"
    sed -i '' '/console\.log.*[Ss]tarting/d' "$file"
    sed -i '' '/console\.log.*[Ee]ndpoint/d' "$file"
    sed -i '' '/console\.log.*[Cc]losed/d' "$file"
    sed -i '' '/console\.log.*[Aa]vailable/d' "$file"
    sed -i '' '/console\.log.*[Ss]aved/d' "$file"
    sed -i '' '/console\.log.*[Dd]eleted/d' "$file"
    sed -i '' '/console\.log.*[Cc]leaned/d' "$file"
    
    # Supprimer les console.log vides
    sed -i '' '/^[[:space:]]*console\.log();[[:space:]]*$/d' "$file"
    
    # Compter les lignes aprÃ¨s modification
    local lines_after=$(wc -l < "$file")
    local removed=$((lines_before - lines_after))
    
    if [ $removed -gt 0 ]; then
        echo "âœ… SupprimÃ© $removed lignes dans $basename_file"
        ((total_removed += removed))
        ((files_modified++))
    else
        echo "â„¹ï¸  Aucune modification dans $basename_file"
        # Supprimer la sauvegarde inutile
        rm "$backup_dir/${basename_file}.backup"
    fi
}

# Traiter tous les fichiers .js
for jsfile in $(find . -name "*.js" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./console_backup_*/*"); do
    process_file "$jsfile"
done

echo ""
echo "ğŸ‰ Nettoyage terminÃ©!"
echo "ğŸ“Š Total lignes supprimÃ©es: $total_removed"
echo "ğŸ“Š Fichiers modifiÃ©s: $files_modified"

if [ $files_modified -eq 0 ]; then
    rmdir "$backup_dir" 2>/dev/null
    echo "â„¹ï¸  Aucune sauvegarde nÃ©cessaire"
else
    echo "ğŸ“‹ Sauvegardes disponibles dans: $backup_dir"
    echo "ğŸ’¡ Pour restaurer: cp $backup_dir/[fichier].backup [fichier_original]"
fi