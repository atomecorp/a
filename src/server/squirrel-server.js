// Serveur Fastify pour la transpilation Squirrel
import fastify from 'fastify';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const server = fastify({ 
  logger: true,
  cors: {
    origin: true,
    credentials: true
  }
});

// Configuration CORS
await server.register(import('@fastify/cors'), {
  origin: true,
  credentials: true
});

// Support pour les requêtes JSON
await server.register(import('@fastify/formbody'));

// Support pour servir les fichiers statiques
await server.register(import('@fastify/static'), {
  root: path.join(__dirname, '..'),
  prefix: '/'
});

const PORT = process.env.SQUIRREL_PORT || 3001;
const OUTPUT_DIR = path.join(__dirname, '..', 'output');

// Créer le dossier de sortie s'il n'existe pas
async function ensureOutputDir() {
  try {
    await fs.access(OUTPUT_DIR);
  } catch {
    await fs.mkdir(OUTPUT_DIR, { recursive: true });
  }
}

// Route pour recevoir et sauvegarder le code transpilé
server.post('/transpile-and-save', async (request, reply) => {
  try {
    const { 
      rubyCode, 
      transpiledCode, 
      filename = 'transpiled.js',
      metadata = {}
    } = request.body;

    if (!transpiledCode) {
      return reply.code(400).send({ 
        error: 'transpiledCode is required',
        success: false 
      });
    }

    // Générer des noms de fichiers fixes (pas de timestamp)
    const baseFilename = path.parse(filename).name;
    const jsFilename = `${baseFilename}.js`;
    const rubyFilename = `${baseFilename}.sqr`;
    const metadataFilename = `${baseFilename}.meta.json`;
    
    const jsFilePath = path.join(OUTPUT_DIR, jsFilename);
    const rubyFilePath = path.join(OUTPUT_DIR, rubyFilename);
    const metadataPath = path.join(OUTPUT_DIR, metadataFilename);

    // Créer le contenu du fichier JavaScript avec des commentaires
    const jsContent = `// Transpiled from Ruby (.sqr) to JavaScript
// Original file: ${filename}
// Transpiled on: ${new Date().toISOString()}
// Generated by Squirrel Transpiler

${transpiledCode}
`;

    // Sauvegarder le code transpilé (JavaScript)
    await fs.writeFile(jsFilePath, jsContent, 'utf8');
    
    // Sauvegarder le code Ruby original si fourni
    if (rubyCode) {
      const rubyContent = `# Original Ruby code for ${filename}
# Saved on: ${new Date().toISOString()}

${rubyCode}
`;
      await fs.writeFile(rubyFilePath, rubyContent, 'utf8');
    }

    // Sauvegarder les métadonnées
    const metadataContent = {
      originalFilename: filename,
      timestamp: new Date().toISOString(),
      jsFile: jsFilename,
      rubyFile: rubyCode ? rubyFilename : null,
      size: {
        javascript: transpiledCode.length,
        ruby: rubyCode ? rubyCode.length : 0
      },
      ...metadata
    };
    
    await fs.writeFile(metadataPath, JSON.stringify(metadataContent, null, 2), 'utf8');


    return reply.send({
      success: true,
      message: 'Code transpilé sauvegardé avec succès',
      files: {
        javascript: jsFilename,
        ruby: rubyCode ? rubyFilename : null,
        metadata: metadataFilename
      },
      paths: {
        javascript: jsFilePath,
        ruby: rubyCode ? rubyFilePath : null,
        metadata: metadataPath
      }
    });

  } catch (error) {
    console.error('❌ Error saving transpiled code:', error);
    return reply.code(500).send({
      error: 'Failed to save transpiled code',
      details: error.message,
      success: false
    });
  }
});

// Route pour lister les fichiers sauvegardés
server.get('/files', async (request, reply) => {
  try {
    const files = await fs.readdir(OUTPUT_DIR);
    const fileDetails = [];

    for (const file of files) {
      const filePath = path.join(OUTPUT_DIR, file);
      const stats = await fs.stat(filePath);
      const ext = path.extname(file);
      
      fileDetails.push({
        name: file,
        size: stats.size,
        created: stats.birthtime,
        modified: stats.mtime,
        type: ext === '.js' ? 'javascript' : 
              ext === '.sqr' ? 'ruby' : 
              ext === '.json' ? 'metadata' : 'unknown'
      });
    }

    return reply.send({
      success: true,
      files: fileDetails.sort((a, b) => b.modified - a.modified)
    });

  } catch (error) {
    console.error('❌ Error listing files:', error);
    return reply.code(500).send({
      error: 'Failed to list files',
      details: error.message,
      success: false
    });
  }
});

// Route pour récupérer un fichier spécifique
server.get('/files/:filename', async (request, reply) => {
  try {
    const { filename } = request.params;
    const filePath = path.join(OUTPUT_DIR, filename);
    
    // Vérifier que le fichier existe et est dans le bon répertoire
    await fs.access(filePath);
    const content = await fs.readFile(filePath, 'utf8');
    
    return reply.send({
      success: true,
      filename,
      content,
      path: filePath
    });

  } catch (error) {
    console.error(`❌ Error reading file ${request.params.filename}:`, error);
    return reply.code(404).send({
      error: 'File not found',
      details: error.message,
      success: false
    });
  }
});

// Route pour supprimer un fichier
server.delete('/files/:filename', async (request, reply) => {
  try {
    const { filename } = request.params;
    const filePath = path.join(OUTPUT_DIR, filename);
    
    await fs.unlink(filePath);
    
    
    return reply.send({
      success: true,
      message: `File ${filename} deleted successfully`
    });

  } catch (error) {
    console.error(`❌ Error deleting file ${request.params.filename}:`, error);
    return reply.code(404).send({
      error: 'Failed to delete file',
      details: error.message,
      success: false
    });
  }
});

// Route de santé
server.get('/health', async (request, reply) => {
  try {
    const outputDirExists = await fs.access(OUTPUT_DIR).then(() => true).catch(() => false);
    const files = outputDirExists ? await fs.readdir(OUTPUT_DIR) : [];
    
    return reply.send({
      status: 'OK',
      timestamp: new Date().toISOString(),
      service: 'Squirrel Transpiler Server',
      outputDir: OUTPUT_DIR,
      outputDirExists,
      filesCount: files.length
    });
  } catch (error) {
    return reply.code(500).send({
      status: 'ERROR',
      error: error.message
    });
  }
});

// Route pour nettoyer tous les fichiers
server.delete('/files', async (request, reply) => {
  try {
    const files = await fs.readdir(OUTPUT_DIR);
    let deletedCount = 0;

    for (const file of files) {
      const filePath = path.join(OUTPUT_DIR, file);
      await fs.unlink(filePath);
      deletedCount++;
    }


    return reply.send({
      success: true,
      message: `Deleted ${deletedCount} files`,
      deletedCount
    });

  } catch (error) {
    console.error('❌ Error cleaning up files:', error);
    return reply.code(500).send({
      error: 'Failed to clean up files',
      details: error.message,
      success: false
    });
  }
});

// Démarrer le serveur
async function startServer() {
  try {
    await ensureOutputDir();
    
    await server.listen({ 
      port: PORT, 
      host: '0.0.0.0' 
    });
    
    console.log(`   POST /transpile-and-save - Save transpiled code`);
    console.log(`   GET  /files/:filename   - Get specific file`);
    console.log(`   DELETE /files/:filename - Delete specific file`);
    console.log(`   DELETE /files           - Clean all files`);
    console.log(`   GET  /health            - Health check`);
    console.log(`   GET  /                  - Serve application files`);
    
  } catch (error) {
    console.error('❌ Error starting server:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGINT', async () => {
  try {
    await server.close();
    process.exit(0);
  } catch (error) {
    console.error('❌ Error during shutdown:', error);
    process.exit(1);
  }
});

startServer();
