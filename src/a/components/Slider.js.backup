/**
 * üéöÔ∏è SLIDER COMPONENT - PARAM√âTRIQUE ET R√âUTILISABLE
 * Compatible avec le framework A
 * Support des types: horizontal, vertical, circular
 */

class Slider {
    constructor(config = {}) {
        // Configuration par d√©faut
        this.config = {
            attach: 'body',
            id: `slider_${Date.now()}`,
            type: 'horizontal', // 'horizontal' | 'vertical' | 'circular'
            x: 50,
            y: 100,
            width: 400,
            height: 120,
            trackWidth: 360,
            trackHeight: 6,
            thumbSize: 24,
            value: 30,
            min: 0,
            max: 100,
            step: 1,
            theme: 'material', // 'material' | 'flat' | 'custom'
            colors: {
                container: '#ffffff',
                track: '#e3f2fd',
                progress: '#2196f3',
                thumb: '#2196f3',
                text: '#424242'
            },
            variation: null, // Tableau de couleurs pour interpolation dynamique
            animations: {
                enabled: true,
                duration: 0.2,
                easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)'
            },
            callbacks: {
                onChange: null,
                onStart: null,
                onEnd: null
            },
            // Configuration sp√©cifique pour les sliders circulaires
            circular: {
                radius: 80,
                strokeWidth: 8,
                startAngle: -90, // Angle de d√©part en degr√©s (-90 = 12h)
                endAngle: 270   // Angle de fin en degr√©s (270 = presque tour complet)
            },
            ...config
        };

        this.isDragging = false;
        this.currentValue = this.config.value;
        this.elements = {};
        
        this._init();
    }

    _init() {
        if (this.config.type === 'circular') {
            this._createCircularSlider();
        } else {
            this._createLinearSlider();
            this._attachEvents();
        }
        this._applyStyles();
        this.setValue(this.config.value);
    }

    _createLinearSlider() {
        this._createContainer();
        this._createTrack();
        this._createProgress();
        this._createThumb();
    }

    _createCircularSlider() {
        this._createCircularContainer();
        this._createCircularTrack();
        this._createCircularProgress();
        this._createCircularThumb();
    }

    _createContainer() {
        const isVertical = this.config.type === 'vertical';
        
        this.elements.container = new A({
            attach: this.config.attach,
            id: this.config.id + '_container',
            markup: 'div',
            role: 'slider-container',
            x: this.config.x,
            y: this.config.y,
            width: isVertical ? this.config.height : this.config.width,
            height: isVertical ? this.config.width : this.config.height,
            backgroundColor: this.config.colors.container,
            smooth: 12,
            padding: 15,
            boxShadow: '0 8px 32px rgba(0,0,0,0.12), 0 2px 6px rgba(0,0,0,0.08)',
            border: '1px solid rgba(0,0,0,0.04)',
            overflow: 'visible'
        });
    }

    _createTrack() {
        const isVertical = this.config.type === 'vertical';
        
        this.elements.track = new A({
            attach: `#${this.config.id}_container`,
            id: this.config.id + '_track',
            markup: 'div',
            x: isVertical ? (this.config.height - this.config.trackHeight) / 2 : 0,
            y: isVertical ? 0 : (this.config.height - this.config.trackHeight) / 2 - 15,
            width: isVertical ? this.config.trackHeight : this.config.trackWidth,
            height: isVertical ? this.config.trackWidth : this.config.trackHeight,
            backgroundColor: this.config.colors.track,
            smooth: 3,
            position: 'relative',
            cursor: 'pointer'
        });
    }

    _createProgress() {
        const isVertical = this.config.type === 'vertical';
        const initialSize = (this.currentValue / (this.config.max - this.config.min)) * 
                           (isVertical ? this.config.trackWidth : this.config.trackWidth);
        
        this.elements.progress = new A({
            attach: `#${this.config.id}_track`,
            id: this.config.id + '_progress',
            markup: 'div',
            x: 0,
            y: isVertical ? this.config.trackWidth - initialSize : 0,
            width: isVertical ? this.config.trackHeight : initialSize,
            height: isVertical ? initialSize : this.config.trackHeight,
            backgroundColor: this.config.colors.progress,
            smooth: 3,
            position: 'absolute',
            transition: this.config.animations.enabled ? 
                       `${isVertical ? 'height' : 'width'} ${this.config.animations.duration}s ${this.config.animations.easing}` : 'none',
            boxShadow: '0 2px 4px rgba(33, 150, 243, 0.3)'
        });
    }

    _createThumb() {
        const isVertical = this.config.type === 'vertical';
        const trackSize = isVertical ? this.config.trackWidth : this.config.trackWidth;
        const initialPosition = (this.currentValue / (this.config.max - this.config.min)) * trackSize - this.config.thumbSize / 2;
        
        this.elements.thumb = new A({
            attach: `#${this.config.id}_track`,
            id: this.config.id + '_thumb',
            markup: 'div',
            x: isVertical ? (this.config.trackHeight - this.config.thumbSize) / 2 : initialPosition,
            y: isVertical ? this.config.trackWidth - initialPosition - this.config.thumbSize : 
               (this.config.trackHeight - this.config.thumbSize) / 2,
            width: this.config.thumbSize,
            height: this.config.thumbSize,
            backgroundColor: this.config.colors.thumb,
            smooth: '50%',
            position: 'absolute',
            cursor: 'pointer',
            transition: this.config.animations.enabled ? 
                       `transform ${this.config.animations.duration}s ${this.config.animations.easing}, box-shadow ${this.config.animations.duration}s ${this.config.animations.easing}` : 'none',
            boxShadow: '0 4px 12px rgba(33, 150, 243, 0.4)',
            border: '3px solid #ffffff'
        });
    }

    _applyStyles() {
        // Appliquer le th√®me
        this._applyTheme();

        // Ajouter les styles CSS pour les animations
        if (!document.getElementById('slider-animations')) {
            const style = document.createElement('style');
            style.id = 'slider-animations';
            style.textContent = `
                @keyframes ripple {
                    to {
                        transform: translate(-50%, -50%) scale(4);
                        opacity: 0;
                    }
                }
                
                .slider-thumb:focus {
                    outline: 2px solid #2196f3;
                    outline-offset: 2px;
                }
            `;
            document.head.appendChild(style);
        }
    }

    _updateVariationColors(percentage) {
        if (!this.config.variation || !Array.isArray(this.config.variation)) {
            // Couleur dynamique par d√©faut (rouge vers vert)
            const hue = percentage * 120; // 0 (rouge) √† 120 (vert)
            const color = `hsl(${hue}, 70%, 50%)`;
            this.elements.progress.html_object.style.backgroundColor = color;
            this.elements.thumb.html_object.style.backgroundColor = color;
            this.elements.thumb.html_object.style.boxShadow = `0 4px 12px hsla(${hue}, 70%, 50%, 0.4)`;
            return;
        }

        // Interpolation entre les couleurs du tableau variation
        const colors = this.config.variation;
        if (colors.length === 0) return;

        // Si on a qu'une couleur, l'utiliser
        if (colors.length === 1) {
            const color = colors[0].color;
            this.elements.progress.html_object.style.backgroundColor = color;
            this.elements.thumb.html_object.style.backgroundColor = color;
            return;
        }

        // Trouver les deux couleurs entre lesquelles interpoler
        let color1 = colors[0];
        let color2 = colors[colors.length - 1];
        
        for (let i = 0; i < colors.length - 1; i++) {
            const currentPos = this._parsePosition(colors[i].position) / 100;
            const nextPos = this._parsePosition(colors[i + 1].position) / 100;
            
            if (percentage >= currentPos && percentage <= nextPos) {
                color1 = colors[i];
                color2 = colors[i + 1];
                break;
            }
        }

        // Calculer le facteur d'interpolation entre les deux couleurs
        const pos1 = this._parsePosition(color1.position) / 100;
        const pos2 = this._parsePosition(color2.position) / 100;
        const factor = pos1 === pos2 ? 0 : (percentage - pos1) / (pos2 - pos1);

        // Interpoler entre les deux couleurs
        const interpolatedColor = this._interpolateColors(color1.color, color2.color, factor);
        
        this.elements.progress.html_object.style.backgroundColor = interpolatedColor;
        this.elements.thumb.html_object.style.backgroundColor = interpolatedColor;
        
        // Ajouter une ombre avec la m√™me couleur
        const shadowColor = this._addAlphaToColor(interpolatedColor, 0.4);
        this.elements.thumb.html_object.style.boxShadow = `0 4px 12px ${shadowColor}`;
    }

    _parsePosition(position) {
        if (typeof position === 'string') {
            return parseFloat(position.replace('%', ''));
        }
        if (typeof position === 'object' && position.x) {
            return parseFloat(position.x.replace('%', ''));
        }
        return 0;
    }

    _interpolateColors(color1, color2, factor) {
        // Convertir les couleurs en RGB
        const rgb1 = this._hexToRgb(color1);
        const rgb2 = this._hexToRgb(color2);
        
        if (!rgb1 || !rgb2) return color1;

        // Interpoler chaque composant RGB
        const r = Math.round(rgb1.r + factor * (rgb2.r - rgb1.r));
        const g = Math.round(rgb1.g + factor * (rgb2.g - rgb1.g));
        const b = Math.round(rgb1.b + factor * (rgb2.b - rgb1.b));

        return `rgb(${r}, ${g}, ${b})`;
    }

    _hexToRgb(hex) {
        // Support pour les couleurs hex (#rrggbb) et nomm√©es
        if (hex.startsWith('#')) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        // Pour les couleurs nomm√©es, cr√©er un √©l√©ment temporaire pour obtenir la valeur RGB
        const tempDiv = document.createElement('div');
        tempDiv.style.color = hex;
        document.body.appendChild(tempDiv);
        const rgbColor = window.getComputedStyle(tempDiv).color;
        document.body.removeChild(tempDiv);
        
        const match = rgbColor.match(/\d+/g);
        return match ? {
            r: parseInt(match[0]),
            g: parseInt(match[1]),
            b: parseInt(match[2])
        } : null;
    }

    _addAlphaToColor(color, alpha) {
        if (color.startsWith('rgb(')) {
            return color.replace('rgb(', 'rgba(').replace(')', `, ${alpha})`);
        }
        return color;
    }

    _applyTheme() {
        const themes = {
            material: {
                containerShadow: '0 8px 32px rgba(0,0,0,0.12), 0 2px 6px rgba(0,0,0,0.08)',
                thumbShadow: '0 4px 12px rgba(33, 150, 243, 0.4)',
                borderRadius: '12px'
            },
            flat: {
                containerShadow: 'none',
                thumbShadow: 'none',
                borderRadius: '0px'
            },
            custom: {} // L'utilisateur peut d√©finir ses propres styles
        };

        const theme = themes[this.config.theme] || themes.material;
        
        if (theme.containerShadow) {
            this.elements.container.html_object.style.boxShadow = theme.containerShadow;
        }
        if (theme.thumbShadow) {
            this.elements.thumb.html_object.style.boxShadow = theme.thumbShadow;
        }
        if (theme.borderRadius) {
            this.elements.container.html_object.style.borderRadius = theme.borderRadius;
        }
    }

    _attachEvents() {
        this._attachHoverEvents();
        this._attachClickEvents();
        this._attachDragEvents();
        this._attachKeyboardEvents();
    }

    _attachHoverEvents() {
        this.elements.thumb.html_object.addEventListener('mouseenter', () => {
            if (!this.isDragging) {
                this.elements.thumb.html_object.style.transform = 'scale(1.2)';
            }
        });

        this.elements.thumb.html_object.addEventListener('mouseleave', () => {
            if (!this.isDragging) {
                this.elements.thumb.html_object.style.transform = 'scale(1)';
            }
        });
    }

    _attachClickEvents() {
        // Seulement pour les sliders lin√©aires
        if (this.config.type !== 'circular') {
            this.elements.track.html_object.addEventListener('click', (e) => {
                if (!this.isDragging) {
                    const newValue = this._getValueFromEvent(e);
                    this.setValue(newValue);
                    this._createRipple(e);
                    this._triggerCallback('onChange', newValue);
                }
            });
        }
    }

    _attachDragEvents() {
        this.elements.thumb.html_object.addEventListener('mousedown', (e) => {
            this._startDrag(e);
        });
    }

    _attachKeyboardEvents() {
        this.elements.thumb.html_object.setAttribute('tabindex', '0');
        this.elements.thumb.html_object.classList.add('slider-thumb');
        
        this.elements.thumb.html_object.addEventListener('keydown', (e) => {
            let newValue = this.currentValue;
            
            switch(e.key) {
                case 'ArrowLeft':
                case 'ArrowDown':
                    newValue -= this.config.step;
                    break;
                case 'ArrowRight':
                case 'ArrowUp':
                    newValue += this.config.step;
                    break;
                case 'Home':
                    newValue = this.config.min;
                    break;
                case 'End':
                    newValue = this.config.max;
                    break;
                default:
                    return;
            }
            
            this.setValue(newValue);
            this._triggerCallback('onChange', newValue);
            e.preventDefault();
        });
    }

    _startDrag(e) {
        this.isDragging = true;
        this.elements.thumb.html_object.style.transform = 'scale(1.3)';
        this.elements.thumb.html_object.style.zIndex = '1000';
        document.body.style.userSelect = 'none';

        // D√©sactiver les transitions pendant le drag
        this.elements.progress.html_object.style.transition = 'none';

        this._triggerCallback('onStart', this.currentValue);

        const handleMouseMove = (e) => {
            if (this.isDragging) {
                const newValue = this._getValueFromEvent(e);
                this.setValue(newValue);
                this._triggerCallback('onChange', newValue);
            }
        };

        const handleMouseUp = () => {
            this.isDragging = false;
            this.elements.thumb.html_object.style.transform = 'scale(1)';
            this.elements.thumb.html_object.style.zIndex = '';
            document.body.style.userSelect = '';

            // R√©activer les transitions
            if (this.config.animations.enabled) {
                const isVertical = this.config.type === 'vertical';
                this.elements.progress.html_object.style.transition = 
                    `${isVertical ? 'height' : 'width'} ${this.config.animations.duration}s ${this.config.animations.easing}`;
            }

            this._triggerCallback('onEnd', this.currentValue);

            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);

        e.preventDefault();
    }

    _getValueFromEvent(e) {
        const isVertical = this.config.type === 'vertical';
        const isCircular = this.config.type === 'circular';
        
        if (isCircular) {
            return this._getValueFromCircularEvent(e);
        }
        
        const trackRect = this.elements.track.html_object.getBoundingClientRect();
        
        let relativePosition;
        if (isVertical) {
            relativePosition = (trackRect.bottom - e.clientY) / trackRect.height;
        } else {
            relativePosition = (e.clientX - trackRect.left) / trackRect.width;
        }
        
        const value = this.config.min + (relativePosition * (this.config.max - this.config.min));
        return Math.max(this.config.min, Math.min(this.config.max, value));
    }

    _createRipple(e) {
        const ripple = document.createElement('div');
        ripple.style.cssText = `
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(33, 150, 243, 0.3);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%) scale(0);
            animation: ripple 0.6s ease-out;
        `;

        const trackRect = this.elements.track.html_object.getBoundingClientRect();
        const isVertical = this.config.type === 'vertical';
        
        if (isVertical) {
            ripple.style.left = '50%';
            ripple.style.top = (e.clientY - trackRect.top) + 'px';
        } else {
            ripple.style.left = (e.clientX - trackRect.left) + 'px';
            ripple.style.top = '50%';
        }

        this.elements.track.html_object.appendChild(ripple);
        setTimeout(() => ripple.remove(), 600);
    }

    _triggerCallback(callbackName, value) {
        const callback = this.config.callbacks[callbackName];
        if (typeof callback === 'function') {
            callback(value, this);
        }
    }

    // API publique
    setValue(value) {
        this.currentValue = Math.max(this.config.min, Math.min(this.config.max, value));
        
        if (this.config.type === 'circular') {
            this._setCircularValue(value);
            return;
        }
        
        const isVertical = this.config.type === 'vertical';
        const trackSize = isVertical ? this.config.trackWidth : this.config.trackWidth;
        const percentage = (this.currentValue - this.config.min) / (this.config.max - this.config.min);
        const progressSize = percentage * trackSize;
        const thumbPosition = progressSize - this.config.thumbSize / 2;

        // Mettre √† jour la barre de progression
        if (isVertical) {
            this.elements.progress.height(progressSize);
            this.elements.progress.y(trackSize - progressSize);
            this.elements.thumb.y(trackSize - progressSize - this.config.thumbSize / 2);
        } else {
            this.elements.progress.width(progressSize);
            this.elements.thumb.x(thumbPosition);
        }

        // Appliquer la variation de couleur bas√©e sur la position
        this._updateVariationColors(percentage);
    }

    getValue() {
        return this.currentValue;
    }

    setConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        this._applyStyles();
    }

    destroy() {
        if (this.elements.container) {
            this.elements.container.html_object.remove();
        }
    }

    // ===== M√âTHODES POUR LES SLIDERS CIRCULAIRES =====
    
    _createCircularContainer() {
        const size = this.config.circular.radius * 2 + this.config.thumbSize + 20;
        
        this.elements.container = new A({
            attach: this.config.attach,
            id: this.config.id + '_container',
            markup: 'div',
            role: 'circular-slider-container',
            x: this.config.x,
            y: this.config.y,
            width: size,
            height: size,
            backgroundColor: this.config.colors.container,
            smooth: 12,
            padding: 10,
            boxShadow: '0 8px 32px rgba(0,0,0,0.12), 0 2px 6px rgba(0,0,0,0.08)',
            border: '1px solid rgba(0,0,0,0.04)',
            overflow: 'visible',
            position: 'relative',
            cursor: 'pointer'
        });
    }

    _createCircularTrack() {
        const { radius, strokeWidth, startAngle, endAngle } = this.config.circular;
        
        // Cr√©er un SVG pour le track circulaire
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        const svgSize = radius * 2 + strokeWidth + 20;
        svg.setAttribute('width', svgSize);
        svg.setAttribute('height', svgSize);
        svg.style.position = 'absolute';
        svg.style.left = '10px';
        svg.style.top = '10px';
        svg.style.pointerEvents = 'auto';
        svg.style.cursor = 'pointer';

        const centerX = radius + strokeWidth / 2 + 10;
        const centerY = radius + strokeWidth / 2 + 10;

        // Track arc (seulement la partie utilisable entre startAngle et endAngle)
        const trackArc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        
        // Calculer le path de l'arc pour le track
        const startRadians = (startAngle - 90) * Math.PI / 180;
        const endRadians = (endAngle - 90) * Math.PI / 180;
        
        const startX = centerX + radius * Math.cos(startRadians);
        const startY = centerY + radius * Math.sin(startRadians);
        const endX = centerX + radius * Math.cos(endRadians);
        const endY = centerY + radius * Math.sin(endRadians);
        
        const angleRange = Math.abs(endAngle - startAngle);
        const largeArcFlag = angleRange > 180 ? 1 : 0;
        const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}`;
        
        trackArc.setAttribute('d', pathData);
        trackArc.setAttribute('fill', 'none');
        trackArc.setAttribute('stroke', this.config.colors.track);
        trackArc.setAttribute('stroke-width', strokeWidth);
        trackArc.setAttribute('stroke-linecap', 'round');
        
        // Ajouter un √©v√©nement de clic sur le track
        trackArc.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const newValue = this._getValueFromCircularEvent(e);
            this.setValue(newValue);
            this._triggerCallback('onChange');
        });

        svg.appendChild(trackArc);
        
        this.elements.container.html_object.appendChild(svg);
        this.elements.track = { 
            html_object: svg, 
            arc: trackArc,
            centerX: centerX,
            centerY: centerY,
            radius: radius
        };
    }
        const endY = centerY + radius * Math.sin(endRadians);
        
        const largeArcFlag = Math.abs(endAngle - startAngle) > 180 ? 1 : 0;
        const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}`;
        
        trackArc.setAttribute('d', pathData);
        trackArc.setAttribute('fill', 'none');
        trackArc.setAttribute('stroke', this.config.colors.track);
        trackArc.setAttribute('stroke-width', strokeWidth);
        trackArc.setAttribute('stroke-linecap', 'round');

        svg.appendChild(trackArc);
        
        this.elements.container.html_object.appendChild(svg);
        this.elements.track = { 
            html_object: svg, 
            arc: trackArc,
            centerX: centerX,
            centerY: centerY,
            radius: radius
        };
    }

    _createCircularProgress() {
        const { radius, strokeWidth } = this.config.circular;
        
        // Progress arc
        const progressArc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        progressArc.setAttribute('fill', 'none');
        progressArc.setAttribute('stroke', this.config.colors.progress);
        progressArc.setAttribute('stroke-width', strokeWidth);
        progressArc.setAttribute('stroke-linecap', 'round');
        
        this.elements.track.html_object.appendChild(progressArc);
        this.elements.progress = { html_object: progressArc };
    }

    _createCircularThumb() {
        const { radius, strokeWidth, startAngle } = this.config.circular;
        const centerX = radius + strokeWidth / 2 + 10;
        const centerY = radius + strokeWidth / 2 + 10;
        
        // Position initiale bas√©e sur la valeur courante
        const percentage = (this.currentValue - this.config.min) / (this.config.max - this.config.min);
        const angleRange = this.config.circular.endAngle - startAngle;
        const currentAngle = startAngle + (percentage * angleRange);
        const radians = (currentAngle - 90) * Math.PI / 180;
        
        const thumbX = centerX + radius * Math.cos(radians) - this.config.thumbSize / 2;
        const thumbY = centerY + radius * Math.sin(radians) - this.config.thumbSize / 2;
        
        this.elements.thumb = new A({
            attach: `#${this.config.id}_container`,
            id: this.config.id + '_thumb',
            markup: 'div',
            x: thumbX,
            y: thumbY,
            width: this.config.thumbSize,
            height: this.config.thumbSize,
            backgroundColor: this.config.colors.thumb,
            smooth: this.config.thumbSize / 2,
            position: 'absolute',
            cursor: 'grab',
            boxShadow: '0 4px 12px rgba(33, 150, 243, 0.4), 0 2px 4px rgba(0,0,0,0.1)',
            border: '3px solid white',
            transition: this.config.animations.enabled ? 
                       `transform ${this.config.animations.duration}s ${this.config.animations.easing}` : 'none',
            zIndex: 10
        });

        // Ajouter les √©v√©nements de drag sp√©cifiques aux sliders circulaires
        this.elements.thumb.html_object.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            this.isDragging = true;
            this.elements.thumb.css('cursor', 'grabbing');
            
            const handleCircularDrag = (moveEvent) => {
                if (!this.isDragging) return;
                
                moveEvent.preventDefault();
                const newValue = this._getValueFromCircularEvent(moveEvent);
                this.setValue(newValue);
                this._triggerCallback('onDrag');
            };

            const handleCircularDragEnd = () => {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.elements.thumb.css('cursor', 'grab');
                    this._triggerCallback('onChange');
                }
                document.removeEventListener('pointermove', handleCircularDrag);
                document.removeEventListener('pointerup', handleCircularDragEnd);
            };

            document.addEventListener('pointermove', handleCircularDrag);
            document.addEventListener('pointerup', handleCircularDragEnd);
        });
    }

    _getValueFromCircularEvent(e) {
        const { radius, strokeWidth, startAngle, endAngle } = this.config.circular;
        const containerRect = this.elements.container.html_object.getBoundingClientRect();
        
        // Utiliser le centre exact du track SVG
        const centerX = containerRect.left + radius + strokeWidth / 2 + 20; // 10px margin + 10px padding
        const centerY = containerRect.top + radius + strokeWidth / 2 + 20;
        
        // Calculer l'angle de la souris par rapport au centre
        const deltaX = e.clientX - centerX;
        const deltaY = e.clientY - centerY;
        let angleDegrees = Math.atan2(deltaY, deltaX) * 180 / Math.PI + 90;
        
        // Normaliser l'angle entre 0 et 360
        if (angleDegrees < 0) angleDegrees += 360;
        if (angleDegrees >= 360) angleDegrees -= 360;
        
        // Calculer la position relative sur l'arc
        let relativePosition;
        const angleRange = endAngle - startAngle;
        
        if (startAngle <= endAngle) {
            // Cas simple : arc ne traverse pas 0¬∞
            if (angleDegrees >= startAngle && angleDegrees <= endAngle) {
                relativePosition = (angleDegrees - startAngle) / angleRange;
            } else {
                // Clamper √† la limite la plus proche
                const distToStart = Math.min(
                    Math.abs(angleDegrees - startAngle),
                    Math.abs(angleDegrees - startAngle + 360),
                    Math.abs(angleDegrees - startAngle - 360)
                );
                const distToEnd = Math.min(
                    Math.abs(angleDegrees - endAngle),
                    Math.abs(angleDegrees - endAngle + 360),
                    Math.abs(angleDegrees - endAngle - 360)
                );
                relativePosition = distToStart < distToEnd ? 0 : 1;
            }
        } else {
            // Cas complexe : arc traverse 0¬∞ (ex: de 300¬∞ √† 60¬∞)
            if (angleDegrees >= startAngle || angleDegrees <= endAngle) {
                if (angleDegrees >= startAngle) {
                    relativePosition = (angleDegrees - startAngle) / (360 + endAngle - startAngle);
                } else {
                    relativePosition = (360 - startAngle + angleDegrees) / (360 + endAngle - startAngle);
                }
            } else {
                // Clamper √† la limite la plus proche
                const distToStart = Math.abs(angleDegrees - startAngle);
                const distToEnd = Math.abs(angleDegrees - endAngle);
                relativePosition = distToStart < distToEnd ? 0 : 1;
            }
        }
        
        // S'assurer que la position relative est entre 0 et 1
        relativePosition = Math.max(0, Math.min(1, relativePosition));
        
        // Convertir en valeur et appliquer le step
        const rawValue = this.config.min + (relativePosition * (this.config.max - this.config.min));
        return Math.round(rawValue / this.config.step) * this.config.step;
    }

    _setCircularValue(value) {
        // S'assurer que la valeur est dans les limites
        this.currentValue = Math.max(this.config.min, Math.min(this.config.max, value));
        
        const percentage = (this.currentValue - this.config.min) / (this.config.max - this.config.min);
        const { radius, strokeWidth, startAngle, endAngle } = this.config.circular;
        
        // Calculer l'angle pour le thumb
        const angleRange = endAngle - startAngle;
        const currentAngle = startAngle + (percentage * angleRange);
        const radians = (currentAngle - 90) * Math.PI / 180;
        
        // Position du thumb avec le centre correct
        const centerX = radius + strokeWidth / 2 + 10;
        const centerY = radius + strokeWidth / 2 + 10;
        const thumbX = centerX + radius * Math.cos(radians) - this.config.thumbSize / 2;
        const thumbY = centerY + radius * Math.sin(radians) - this.config.thumbSize / 2;
        
        this.elements.thumb.x(thumbX);
        this.elements.thumb.y(thumbY);
        
        // Mettre √† jour l'arc de progression
        this._updateCircularProgress(percentage);
        
        // Appliquer la variation de couleur
        this._updateVariationColors(percentage);
    }

    _updateCircularProgress(percentage) {
        const { radius, strokeWidth, startAngle, endAngle } = this.config.circular;
        const centerX = radius + strokeWidth / 2 + 10;
        const centerY = radius + strokeWidth / 2 + 10;
        
        const angleRange = endAngle - startAngle;
        const progressAngle = startAngle + (percentage * angleRange);
        
        const startRadians = (startAngle - 90) * Math.PI / 180;
        const endRadians = (progressAngle - 90) * Math.PI / 180;
        
        const startX = centerX + radius * Math.cos(startRadians);
        const startY = centerY + radius * Math.sin(startRadians);
        const endX = centerX + radius * Math.cos(endRadians);
        const endY = centerY + radius * Math.sin(endRadians);
        
        // Calculer si on a besoin d'un grand arc
        const progressAngleRange = Math.abs(progressAngle - startAngle);
        const largeArcFlag = progressAngleRange > 180 ? 1 : 0;
        
        let pathData;
        if (percentage <= 0.001) {
            // Pas de progression visible
            pathData = `M ${startX} ${startY} L ${startX} ${startY}`;
        } else {
            pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}`;
        }
        
        this.elements.progress.html_object.setAttribute('d', pathData);
    }
}

// Export pour utilisation globale
window.Slider = Slider;
export default Slider;
