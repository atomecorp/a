# Specification for a Hybrid Development System (DSL + Rust + JS)

## Objective

Create a development environment combining the flexibility of a simple, elegant, and practical scripting language, the performance of Rust, and the simplicity of a user interface built in JavaScript.

## Main Components

### 1. **DSL (Domain-Specific Language)**

* **Elegant scripting language**: Inspired by the simplicity and power of dynamic languages, offering advanced features such as:

  * **Simple hash tables**: Intuitive data collections.
  * **Dynamic methods**: Ability to define methods at runtime (`define_method`), check message responses (`respond_to?`), and inspect objects (`inspect`).
  * **Metaprogramming**: Modify the behavior of objects and classes dynamically.

### 2. **JavaScript Generation**

* **DSL Compilation**: Code written in the DSL is automatically translated into pure JavaScript for manipulating the user interface, ensuring maximum responsiveness.

### 3. **Rust Backend**

* **Heavy operations**: Complex operations and intensive computations are handled by Rust modules compiled to native code for optimal performance.
* **API Interface**: An API facilitates communication between the JavaScript frontend and the Rust backend for critical processing.

### 4. **Interoperability**

* **Smooth communication**: A high-performance mechanism exchanges data between JS (UI) and Rust (backend) with minimal latency.
* **Optional WebAssembly**: Possibility to use WebAssembly for Rust parts when needed, while limiting its use to avoid performance loss.

## Summary of Advantages

* **Performance**: Rust handles critical tasks, JavaScript manages the UI—resulting in high overall performance.
* **Flexibility**: The scripting language enables intuitive, powerful code with advanced metaprogramming capabilities.
* **Interoperability**: A performant bridge between frontend and backend leverages each technology’s strengths.

## Minimal DSL Example (Editable Text Inline, Events, Metaprogramming)

```text
page = box(id: :main, width: :full, height: :full, attach: :body)

note = text(id: :note,
			content: "✎ Edit me inline",
			editable: true,         # maps to contenteditable
			draggable: true,
			left: 88,
			top: 88,
			style: { font_size: 20, color: :blue })

note.on(:key_down) do |e|
  puts "Key: #{e[:key]}"
end

note.define_method(:highlight) do
  self[:color] = :red
end

note.instance_var_write(:saved_text, "Initial value")

puts note.instance_var_read(:saved_text)        # -> "Initial value"
puts note.respond_to?(:highlight)               # -> true
puts note.inspect                               # -> full DSL object dump

# Call to a Rust backend function for a heavy computation
data = { name: "John", age: 42 }
result = rust(:process_data, data)
puts "Rust response: \#{result}"

```

# Rust Parser and Backend for DSL

This file contains the minimal Rust code to:

* Parse a simple DSL object
* Convert it into JavaScript
* Handle a backend method `process_data` exposed to Tauri frontend

---

## Node Parser and JS Generator

```rust
use serde_json::json;
use std::collections::HashMap;

// Simulate a simple node structure for UI elements
#[derive(Debug)]
struct Node {
    id: String,
    element_type: String,
    properties: HashMap<String, serde_json::Value>,
}

impl Node {
    fn new(id: &str, element_type: &str) -> Self {
        Node {
            id: id.to_string(),
            element_type: element_type.to_string(),
            properties: HashMap::new(),
        }
    }

    fn set(&mut self, key: &str, value: serde_json::Value) {
        self.properties.insert(key.to_string(), value);
    }

    fn to_js(&self) -> String {
        let props = serde_json::to_string(&self.properties).unwrap();
        format!("createNode('{}', '{}', {});", self.id, self.element_type, props)
    }
}

// DSL instruction handler (simplified)
pub fn parse_dsl() -> Vec<String> {
    let mut node = Node::new("note", "text");
    node.set("content", json!("✎ Edit me inline"));
    node.set("editable", json!(true));
    node.set("draggable", json!(true));
    node.set("left", json!(88));
    node.set("top", json!(88));
    node.set("style", json!({ "font_size": 20, "color": "blue" }));
    vec![node.to_js()]
}
```

---

## Backend Method for Heavy Processing

```rust
pub fn process_data(data: HashMap<String, serde_json::Value>) -> String {
    let name = data.get("name").unwrap_or(&json!("unknown"));
    let age = data.get("age").unwrap_or(&json!(0));
    format!("Processed user {} aged {}", name, age)
}
```

<!-- This backend module can be imported and exposed via `tauri.conf.json` to allow communication from the DSL/frontend.-->

# JavaScript Output from DSL Parser (Full UI Interaction)

This file contains the full JavaScript auto-generated by the DSL-to-JS Rust parser.
It includes:

* Creation of a `div` for text with `contenteditable`
* Drag and drop
* Keyboard event capture
* Dynamic style application
* A simulated `.highlight()` method

```js
// dsl_generated.js — Auto-generated from DSL parser in Rust

function createNode(id, type, props) {
  const el = document.createElement(type === "text" ? "div" : type);
  el.id = id;

  if (props.content) el.textContent = props.content;
  if (props.editable) el.contentEditable = true;

  el.style.position = "absolute";
  if (props.left !== undefined) el.style.left = props.left + "px";
  if (props.top !== undefined) el.style.top = props.top + "px";

  if (props.style) {
    Object.entries(props.style).forEach(([key, value]) => {
      const cssKey = key.replace(/_/g, "-");
      el.style[cssKey] = typeof value === "number" ? value + "px" : value;
    });
  }

  if (props.draggable) {
    el.draggable = true;
    el.addEventListener("dragstart", (e) => {
      e.dataTransfer.setData("text/plain", id);
    });
  }

  // Add keyboard interaction capture
  el.addEventListener("keydown", (e) => {
    console.log("Key pressed:", e.key);
    if (e.key === "r") el.style.color = "red"; // test behavior
  });

  // Optional: highlight method (simulate DSL-defined method)
  el.highlight = () => {
    el.style.color = "red";
  };

  document.body.appendChild(el);
  return el;
}

// DSL output simulated from Rust
createNode("note", "text", {
  content: "✎ Edit me inline",
  editable: true,
  draggable: true,
  left: 88,
  top: 88,
  style: {
    font_size: 20,
    color: "blue"
  }
});
```

You can embed this file into an HTML file to test behavior directly in the browser.


---

This document serves as a guide for engineers or development teams to implement the full solution described.
