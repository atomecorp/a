/**
 * A location in the source code.
 *
 * @typedef {{ startOffset: number, length: number }} Location
 */
/**
 * An encoded Ruby string.
 *
 * @typedef {{ value: string, encoding: string, validEncoding: boolean }} RubyString
 */
/**
 * A generic node in the tree.
 *
 * @typedef {(AliasGlobalVariableNode|AliasMethodNode|AlternationPatternNode|AndNode|ArgumentsNode|ArrayNode|ArrayPatternNode|AssocNode|AssocSplatNode|BackReferenceReadNode|BeginNode|BlockArgumentNode|BlockLocalVariableNode|BlockNode|BlockParameterNode|BlockParametersNode|BreakNode|CallAndWriteNode|CallNode|CallOperatorWriteNode|CallOrWriteNode|CallTargetNode|CapturePatternNode|CaseMatchNode|CaseNode|ClassNode|ClassVariableAndWriteNode|ClassVariableOperatorWriteNode|ClassVariableOrWriteNode|ClassVariableReadNode|ClassVariableTargetNode|ClassVariableWriteNode|ConstantAndWriteNode|ConstantOperatorWriteNode|ConstantOrWriteNode|ConstantPathAndWriteNode|ConstantPathNode|ConstantPathOperatorWriteNode|ConstantPathOrWriteNode|ConstantPathTargetNode|ConstantPathWriteNode|ConstantReadNode|ConstantTargetNode|ConstantWriteNode|DefNode|DefinedNode|ElseNode|EmbeddedStatementsNode|EmbeddedVariableNode|EnsureNode|FalseNode|FindPatternNode|FlipFlopNode|FloatNode|ForNode|ForwardingArgumentsNode|ForwardingParameterNode|ForwardingSuperNode|GlobalVariableAndWriteNode|GlobalVariableOperatorWriteNode|GlobalVariableOrWriteNode|GlobalVariableReadNode|GlobalVariableTargetNode|GlobalVariableWriteNode|HashNode|HashPatternNode|IfNode|ImaginaryNode|ImplicitNode|ImplicitRestNode|InNode|IndexAndWriteNode|IndexOperatorWriteNode|IndexOrWriteNode|IndexTargetNode|InstanceVariableAndWriteNode|InstanceVariableOperatorWriteNode|InstanceVariableOrWriteNode|InstanceVariableReadNode|InstanceVariableTargetNode|InstanceVariableWriteNode|IntegerNode|InterpolatedMatchLastLineNode|InterpolatedRegularExpressionNode|InterpolatedStringNode|InterpolatedSymbolNode|InterpolatedXStringNode|ItLocalVariableReadNode|ItParametersNode|KeywordHashNode|KeywordRestParameterNode|LambdaNode|LocalVariableAndWriteNode|LocalVariableOperatorWriteNode|LocalVariableOrWriteNode|LocalVariableReadNode|LocalVariableTargetNode|LocalVariableWriteNode|MatchLastLineNode|MatchPredicateNode|MatchRequiredNode|MatchWriteNode|MissingNode|ModuleNode|MultiTargetNode|MultiWriteNode|NextNode|NilNode|NoKeywordsParameterNode|NumberedParametersNode|NumberedReferenceReadNode|OptionalKeywordParameterNode|OptionalParameterNode|OrNode|ParametersNode|ParenthesesNode|PinnedExpressionNode|PinnedVariableNode|PostExecutionNode|PreExecutionNode|ProgramNode|RangeNode|RationalNode|RedoNode|RegularExpressionNode|RequiredKeywordParameterNode|RequiredParameterNode|RescueModifierNode|RescueNode|RestParameterNode|RetryNode|ReturnNode|SelfNode|ShareableConstantNode|SingletonClassNode|SourceEncodingNode|SourceFileNode|SourceLineNode|SplatNode|StatementsNode|StringNode|SuperNode|SymbolNode|TrueNode|UndefNode|UnlessNode|UntilNode|WhenNode|WhileNode|XStringNode|YieldNode)} Node
 */
/**
 * Represents the use of the `alias` keyword to alias a global variable.
 *
 *     alias $foo $bar
 *     ^^^^^^^^^^^^^^^
 */
export class AliasGlobalVariableNode {
    /**
     * Construct a new AliasGlobalVariableNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} newName
     * @param {Node} oldName
     * @param {Location} keywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, newName: Node, oldName: Node, keywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    newName: Node;
    /**
     * @type Node
     */
    oldName: Node;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `alias` keyword to alias a method.
 *
 *     alias foo bar
 *     ^^^^^^^^^^^^^
 */
export class AliasMethodNode {
    /**
     * Construct a new AliasMethodNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} newName
     * @param {Node} oldName
     * @param {Location} keywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, newName: Node, oldName: Node, keywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    newName: Node;
    /**
     * @type Node
     */
    oldName: Node;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an alternation pattern in pattern matching.
 *
 *     foo => bar | baz
 *            ^^^^^^^^^
 */
export class AlternationPatternNode {
    /**
     * Construct a new AlternationPatternNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} left
     * @param {Node} right
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, left: Node, right: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    left: Node;
    /**
     * @type Node
     */
    right: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `&&` operator or the `and` keyword.
 *
 *     left and right
 *     ^^^^^^^^^^^^^^
 */
export class AndNode {
    /**
     * Construct a new AndNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} left
     * @param {Node} right
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, left: Node, right: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    left: Node;
    /**
     * @type Node
     */
    right: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a set of arguments to a method or a keyword.
 *
 *     return foo, bar, baz
 *            ^^^^^^^^^^^^^
 */
export class ArgumentsNode {
    /**
     * Construct a new ArgumentsNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node[]} arguments_
     */
    constructor(nodeID: number, location: Location, flags: number, arguments_: Node[]);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node[]
     */
    arguments_: Node[];
    /**
     * True if this node has the CONTAINS_FORWARDING flag.
     *
     * @returns {boolean}
     */
    isContainsForwarding(): boolean;
    /**
     * True if this node has the CONTAINS_KEYWORDS flag.
     *
     * @returns {boolean}
     */
    isContainsKeywords(): boolean;
    /**
     * True if this node has the CONTAINS_KEYWORD_SPLAT flag.
     *
     * @returns {boolean}
     */
    isContainsKeywordSplat(): boolean;
    /**
     * True if this node has the CONTAINS_SPLAT flag.
     *
     * @returns {boolean}
     */
    isContainsSplat(): boolean;
    /**
     * True if this node has the CONTAINS_MULTIPLE_SPLATS flag.
     *
     * @returns {boolean}
     */
    isContainsMultipleSplats(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.
 *
 *     [1, 2, 3]
 *     ^^^^^^^^^
 */
export class ArrayNode {
    /**
     * Construct a new ArrayNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node[]} elements
     * @param {Location | null} openingLoc
     * @param {Location | null} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, elements: Node[], openingLoc: Location | null, closingLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node[]
     */
    elements: Node[];
    /**
     * @type Location | null
     */
    openingLoc: Location | null;
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * True if this node has the CONTAINS_SPLAT flag.
     *
     * @returns {boolean}
     */
    isContainsSplat(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an array pattern in pattern matching.
 *
 *     foo in 1, 2
 *     ^^^^^^^^^^^
 *
 *     foo in [1, 2]
 *     ^^^^^^^^^^^^^
 *
 *     foo in *bar
 *     ^^^^^^^^^^^
 *
 *     foo in Bar[]
 *     ^^^^^^^^^^^^
 *
 *     foo in Bar[1, 2, 3]
 *     ^^^^^^^^^^^^^^^^^^^
 */
export class ArrayPatternNode {
    /**
     * Construct a new ArrayPatternNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} constant
     * @param {Node[]} requireds
     * @param {Node | null} rest
     * @param {Node[]} posts
     * @param {Location | null} openingLoc
     * @param {Location | null} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, constant: Node | null, requireds: Node[], rest: Node | null, posts: Node[], openingLoc: Location | null, closingLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    constant: Node | null;
    /**
     * @type Node[]
     */
    requireds: Node[];
    /**
     * @type Node | null
     */
    rest: Node | null;
    /**
     * @type Node[]
     */
    posts: Node[];
    /**
     * @type Location | null
     */
    openingLoc: Location | null;
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a hash key/value pair.
 *
 *     { a => b }
 *       ^^^^^^
 */
export class AssocNode {
    /**
     * Construct a new AssocNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} key
     * @param {Node} value
     * @param {Location | null} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, key: Node, value: Node, operatorLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    key: Node;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type Location | null
     */
    operatorLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a splat in a hash literal.
 *
 *     { **foo }
 *       ^^^^^
 */
export class AssocSplatNode {
    /**
     * Construct a new AssocSplatNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} value
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, value: Node | null, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    value: Node | null;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents reading a reference to a field in the previous match.
 *
 *     $'
 *     ^^
 */
export class BackReferenceReadNode {
    /**
     * Construct a new BackReferenceReadNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a begin statement.
 *
 *     begin
 *       foo
 *     end
 *     ^^^^^
 */
export class BeginNode {
    /**
     * Construct a new BeginNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location | null} beginKeywordLoc
     * @param {StatementsNode | null} statements
     * @param {RescueNode | null} rescueClause
     * @param {ElseNode | null} elseClause
     * @param {EnsureNode | null} ensureClause
     * @param {Location | null} endKeywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, beginKeywordLoc: Location | null, statements: StatementsNode | null, rescueClause: RescueNode | null, elseClause: ElseNode | null, ensureClause: EnsureNode | null, endKeywordLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location | null
     */
    beginKeywordLoc: Location | null;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type RescueNode | null
     */
    rescueClause: RescueNode | null;
    /**
     * @type ElseNode | null
     */
    elseClause: ElseNode | null;
    /**
     * @type EnsureNode | null
     */
    ensureClause: EnsureNode | null;
    /**
     * @type Location | null
     */
    endKeywordLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a block argument using `&`.
 *
 *     bar(&args)
 *     ^^^^^^^^^^
 */
export class BlockArgumentNode {
    /**
     * Construct a new BlockArgumentNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} expression
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, expression: Node | null, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    expression: Node | null;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a block local variable.
 *
 *     a { |; b| }
 *            ^
 */
export class BlockLocalVariableNode {
    /**
     * Construct a new BlockLocalVariableNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * True if this node has the REPEATED_PARAMETER flag.
     *
     * @returns {boolean}
     */
    isRepeatedParameter(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a block of ruby code.
 *
 *     [1, 2, 3].each { |i| puts x }
 *                    ^^^^^^^^^^^^^^
 */
export class BlockNode {
    /**
     * Construct a new BlockNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string[]} locals
     * @param {Node | null} parameters
     * @param {Node | null} body
     * @param {Location} openingLoc
     * @param {Location} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, locals: string[], parameters: Node | null, body: Node | null, openingLoc: Location, closingLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string[]
     */
    locals: string[];
    /**
     * @type Node | null
     */
    parameters: Node | null;
    /**
     * @type Node | null
     */
    body: Node | null;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a block parameter of a method, block, or lambda definition.
 *
 *     def a(&b)
 *           ^^
 *     end
 */
export class BlockParameterNode {
    /**
     * Construct a new BlockParameterNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string | null} name
     * @param {Location | null} nameLoc
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, name: string | null, nameLoc: Location | null, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string | null
     */
    name: string | null;
    /**
     * @type Location | null
     */
    nameLoc: Location | null;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * True if this node has the REPEATED_PARAMETER flag.
     *
     * @returns {boolean}
     */
    isRepeatedParameter(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a block's parameters declaration.
 *
 *     -> (a, b = 1; local) { }
 *        ^^^^^^^^^^^^^^^^^
 *
 *     foo do |a, b = 1; local|
 *            ^^^^^^^^^^^^^^^^^
 *     end
 */
export class BlockParametersNode {
    /**
     * Construct a new BlockParametersNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {ParametersNode | null} parameters
     * @param {Node[]} locals
     * @param {Location | null} openingLoc
     * @param {Location | null} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, parameters: ParametersNode | null, locals: Node[], openingLoc: Location | null, closingLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type ParametersNode | null
     */
    parameters: ParametersNode | null;
    /**
     * @type Node[]
     */
    locals: Node[];
    /**
     * @type Location | null
     */
    openingLoc: Location | null;
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `break` keyword.
 *
 *     break foo
 *     ^^^^^^^^^
 */
export class BreakNode {
    /**
     * Construct a new BreakNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {ArgumentsNode | null} arguments_
     * @param {Location} keywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, arguments_: ArgumentsNode | null, keywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type ArgumentsNode | null
     */
    arguments_: ArgumentsNode | null;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `&&=` operator on a call.
 *
 *     foo.bar &&= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class CallAndWriteNode {
    /**
     * Construct a new CallAndWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} receiver
     * @param {Location | null} callOperatorLoc
     * @param {Location | null} messageLoc
     * @param {string} readName
     * @param {string} writeName
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, receiver: Node | null, callOperatorLoc: Location | null, messageLoc: Location | null, readName: string, writeName: string, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    receiver: Node | null;
    /**
     * @type Location | null
     */
    callOperatorLoc: Location | null;
    /**
     * @type Location | null
     */
    messageLoc: Location | null;
    /**
     * @type string
     */
    readName: string;
    /**
     * @type string
     */
    writeName: string;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * True if this node has the SAFE_NAVIGATION flag.
     *
     * @returns {boolean}
     */
    isSafeNavigation(): boolean;
    /**
     * True if this node has the VARIABLE_CALL flag.
     *
     * @returns {boolean}
     */
    isVariableCall(): boolean;
    /**
     * True if this node has the ATTRIBUTE_WRITE flag.
     *
     * @returns {boolean}
     */
    isAttributeWrite(): boolean;
    /**
     * True if this node has the IGNORE_VISIBILITY flag.
     *
     * @returns {boolean}
     */
    isIgnoreVisibility(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a method call, in all of the various forms that can take.
 *
 *     foo
 *     ^^^
 *
 *     foo()
 *     ^^^^^
 *
 *     +foo
 *     ^^^^
 *
 *     foo + bar
 *     ^^^^^^^^^
 *
 *     foo.bar
 *     ^^^^^^^
 *
 *     foo&.bar
 *     ^^^^^^^^
 */
export class CallNode {
    /**
     * Construct a new CallNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} receiver
     * @param {Location | null} callOperatorLoc
     * @param {string} name
     * @param {Location | null} messageLoc
     * @param {Location | null} openingLoc
     * @param {ArgumentsNode | null} arguments_
     * @param {Location | null} closingLoc
     * @param {Node | null} block
     */
    constructor(nodeID: number, location: Location, flags: number, receiver: Node | null, callOperatorLoc: Location | null, name: string, messageLoc: Location | null, openingLoc: Location | null, arguments_: ArgumentsNode | null, closingLoc: Location | null, block: Node | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    receiver: Node | null;
    /**
     * @type Location | null
     */
    callOperatorLoc: Location | null;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location | null
     */
    messageLoc: Location | null;
    /**
     * @type Location | null
     */
    openingLoc: Location | null;
    /**
     * @type ArgumentsNode | null
     */
    arguments_: ArgumentsNode | null;
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * @type Node | null
     */
    block: Node | null;
    /**
     * True if this node has the SAFE_NAVIGATION flag.
     *
     * @returns {boolean}
     */
    isSafeNavigation(): boolean;
    /**
     * True if this node has the VARIABLE_CALL flag.
     *
     * @returns {boolean}
     */
    isVariableCall(): boolean;
    /**
     * True if this node has the ATTRIBUTE_WRITE flag.
     *
     * @returns {boolean}
     */
    isAttributeWrite(): boolean;
    /**
     * True if this node has the IGNORE_VISIBILITY flag.
     *
     * @returns {boolean}
     */
    isIgnoreVisibility(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of an assignment operator on a call.
 *
 *     foo.bar += baz
 *     ^^^^^^^^^^^^^^
 */
export class CallOperatorWriteNode {
    /**
     * Construct a new CallOperatorWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} receiver
     * @param {Location | null} callOperatorLoc
     * @param {Location | null} messageLoc
     * @param {string} readName
     * @param {string} writeName
     * @param {string} binaryOperator
     * @param {Location} binaryOperatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, receiver: Node | null, callOperatorLoc: Location | null, messageLoc: Location | null, readName: string, writeName: string, binaryOperator: string, binaryOperatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    receiver: Node | null;
    /**
     * @type Location | null
     */
    callOperatorLoc: Location | null;
    /**
     * @type Location | null
     */
    messageLoc: Location | null;
    /**
     * @type string
     */
    readName: string;
    /**
     * @type string
     */
    writeName: string;
    /**
     * @type string
     */
    binaryOperator: string;
    /**
     * @type Location
     */
    binaryOperatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * True if this node has the SAFE_NAVIGATION flag.
     *
     * @returns {boolean}
     */
    isSafeNavigation(): boolean;
    /**
     * True if this node has the VARIABLE_CALL flag.
     *
     * @returns {boolean}
     */
    isVariableCall(): boolean;
    /**
     * True if this node has the ATTRIBUTE_WRITE flag.
     *
     * @returns {boolean}
     */
    isAttributeWrite(): boolean;
    /**
     * True if this node has the IGNORE_VISIBILITY flag.
     *
     * @returns {boolean}
     */
    isIgnoreVisibility(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `||=` operator on a call.
 *
 *     foo.bar ||= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class CallOrWriteNode {
    /**
     * Construct a new CallOrWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} receiver
     * @param {Location | null} callOperatorLoc
     * @param {Location | null} messageLoc
     * @param {string} readName
     * @param {string} writeName
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, receiver: Node | null, callOperatorLoc: Location | null, messageLoc: Location | null, readName: string, writeName: string, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    receiver: Node | null;
    /**
     * @type Location | null
     */
    callOperatorLoc: Location | null;
    /**
     * @type Location | null
     */
    messageLoc: Location | null;
    /**
     * @type string
     */
    readName: string;
    /**
     * @type string
     */
    writeName: string;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * True if this node has the SAFE_NAVIGATION flag.
     *
     * @returns {boolean}
     */
    isSafeNavigation(): boolean;
    /**
     * True if this node has the VARIABLE_CALL flag.
     *
     * @returns {boolean}
     */
    isVariableCall(): boolean;
    /**
     * True if this node has the ATTRIBUTE_WRITE flag.
     *
     * @returns {boolean}
     */
    isAttributeWrite(): boolean;
    /**
     * True if this node has the IGNORE_VISIBILITY flag.
     *
     * @returns {boolean}
     */
    isIgnoreVisibility(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents assigning to a method call.
 *
 *     foo.bar, = 1
 *     ^^^^^^^
 *
 *     begin
 *     rescue => foo.bar
 *               ^^^^^^^
 *     end
 *
 *     for foo.bar in baz do end
 *         ^^^^^^^
 */
export class CallTargetNode {
    /**
     * Construct a new CallTargetNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} receiver
     * @param {Location} callOperatorLoc
     * @param {string} name
     * @param {Location} messageLoc
     */
    constructor(nodeID: number, location: Location, flags: number, receiver: Node, callOperatorLoc: Location, name: string, messageLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    receiver: Node;
    /**
     * @type Location
     */
    callOperatorLoc: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    messageLoc: Location;
    /**
     * True if this node has the SAFE_NAVIGATION flag.
     *
     * @returns {boolean}
     */
    isSafeNavigation(): boolean;
    /**
     * True if this node has the VARIABLE_CALL flag.
     *
     * @returns {boolean}
     */
    isVariableCall(): boolean;
    /**
     * True if this node has the ATTRIBUTE_WRITE flag.
     *
     * @returns {boolean}
     */
    isAttributeWrite(): boolean;
    /**
     * True if this node has the IGNORE_VISIBILITY flag.
     *
     * @returns {boolean}
     */
    isIgnoreVisibility(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents assigning to a local variable in pattern matching.
 *
 *     foo => [bar => baz]
 *            ^^^^^^^^^^^^
 */
export class CapturePatternNode {
    /**
     * Construct a new CapturePatternNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} value
     * @param {LocalVariableTargetNode} target
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, value: Node, target: LocalVariableTargetNode, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type LocalVariableTargetNode
     */
    target: LocalVariableTargetNode;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of a case statement for pattern matching.
 *
 *     case true
 *     in false
 *     end
 *     ^^^^^^^^^
 */
export class CaseMatchNode {
    /**
     * Construct a new CaseMatchNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} predicate
     * @param {Node[]} conditions
     * @param {ElseNode | null} elseClause
     * @param {Location} caseKeywordLoc
     * @param {Location} endKeywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, predicate: Node | null, conditions: Node[], elseClause: ElseNode | null, caseKeywordLoc: Location, endKeywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    predicate: Node | null;
    /**
     * @type Node[]
     */
    conditions: Node[];
    /**
     * @type ElseNode | null
     */
    elseClause: ElseNode | null;
    /**
     * @type Location
     */
    caseKeywordLoc: Location;
    /**
     * @type Location
     */
    endKeywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of a case statement.
 *
 *     case true
 *     when false
 *     end
 *     ^^^^^^^^^^
 */
export class CaseNode {
    /**
     * Construct a new CaseNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} predicate
     * @param {Node[]} conditions
     * @param {ElseNode | null} elseClause
     * @param {Location} caseKeywordLoc
     * @param {Location} endKeywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, predicate: Node | null, conditions: Node[], elseClause: ElseNode | null, caseKeywordLoc: Location, endKeywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    predicate: Node | null;
    /**
     * @type Node[]
     */
    conditions: Node[];
    /**
     * @type ElseNode | null
     */
    elseClause: ElseNode | null;
    /**
     * @type Location
     */
    caseKeywordLoc: Location;
    /**
     * @type Location
     */
    endKeywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a class declaration involving the `class` keyword.
 *
 *     class Foo end
 *     ^^^^^^^^^^^^^
 */
export class ClassNode {
    /**
     * Construct a new ClassNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string[]} locals
     * @param {Location} classKeywordLoc
     * @param {Node} constantPath
     * @param {Location | null} inheritanceOperatorLoc
     * @param {Node | null} superclass
     * @param {Node | null} body
     * @param {Location} endKeywordLoc
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, locals: string[], classKeywordLoc: Location, constantPath: Node, inheritanceOperatorLoc: Location | null, superclass: Node | null, body: Node | null, endKeywordLoc: Location, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string[]
     */
    locals: string[];
    /**
     * @type Location
     */
    classKeywordLoc: Location;
    /**
     * @type Node
     */
    constantPath: Node;
    /**
     * @type Location | null
     */
    inheritanceOperatorLoc: Location | null;
    /**
     * @type Node | null
     */
    superclass: Node | null;
    /**
     * @type Node | null
     */
    body: Node | null;
    /**
     * @type Location
     */
    endKeywordLoc: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `&&=` operator for assignment to a class variable.
 *
 *     @@target &&= value
 *     ^^^^^^^^^^^^^^^^^^
 */
export class ClassVariableAndWriteNode {
    /**
     * Construct a new ClassVariableAndWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents assigning to a class variable using an operator that isn't `=`.
 *
 *     @@target += value
 *     ^^^^^^^^^^^^^^^^^
 */
export class ClassVariableOperatorWriteNode {
    /**
     * Construct a new ClassVariableOperatorWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} binaryOperatorLoc
     * @param {Node} value
     * @param {string} binaryOperator
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, binaryOperatorLoc: Location, value: Node, binaryOperator: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    binaryOperatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type string
     */
    binaryOperator: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `||=` operator for assignment to a class variable.
 *
 *     @@target ||= value
 *     ^^^^^^^^^^^^^^^^^^
 */
export class ClassVariableOrWriteNode {
    /**
     * Construct a new ClassVariableOrWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents referencing a class variable.
 *
 *     @@foo
 *     ^^^^^
 */
export class ClassVariableReadNode {
    /**
     * Construct a new ClassVariableReadNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to a class variable in a context that doesn't have an explicit value.
 *
 *     @@foo, @@bar = baz
 *     ^^^^^  ^^^^^
 */
export class ClassVariableTargetNode {
    /**
     * Construct a new ClassVariableTargetNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to a class variable.
 *
 *     @@foo = 1
 *     ^^^^^^^^^
 */
export class ClassVariableWriteNode {
    /**
     * Construct a new ClassVariableWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Node} value
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, value: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `&&=` operator for assignment to a constant.
 *
 *     Target &&= value
 *     ^^^^^^^^^^^^^^^^
 */
export class ConstantAndWriteNode {
    /**
     * Construct a new ConstantAndWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents assigning to a constant using an operator that isn't `=`.
 *
 *     Target += value
 *     ^^^^^^^^^^^^^^^
 */
export class ConstantOperatorWriteNode {
    /**
     * Construct a new ConstantOperatorWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} binaryOperatorLoc
     * @param {Node} value
     * @param {string} binaryOperator
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, binaryOperatorLoc: Location, value: Node, binaryOperator: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    binaryOperatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type string
     */
    binaryOperator: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `||=` operator for assignment to a constant.
 *
 *     Target ||= value
 *     ^^^^^^^^^^^^^^^^
 */
export class ConstantOrWriteNode {
    /**
     * Construct a new ConstantOrWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `&&=` operator for assignment to a constant path.
 *
 *     Parent::Child &&= value
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class ConstantPathAndWriteNode {
    /**
     * Construct a new ConstantPathAndWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {ConstantPathNode} target
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, target: ConstantPathNode, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type ConstantPathNode
     */
    target: ConstantPathNode;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents accessing a constant through a path of `::` operators.
 *
 *     Foo::Bar
 *     ^^^^^^^^
 */
export class ConstantPathNode {
    /**
     * Construct a new ConstantPathNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} parent
     * @param {string | null} name
     * @param {Location} delimiterLoc
     * @param {Location} nameLoc
     */
    constructor(nodeID: number, location: Location, flags: number, parent: Node | null, name: string | null, delimiterLoc: Location, nameLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    parent: Node | null;
    /**
     * @type string | null
     */
    name: string | null;
    /**
     * @type Location
     */
    delimiterLoc: Location;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents assigning to a constant path using an operator that isn't `=`.
 *
 *     Parent::Child += value
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class ConstantPathOperatorWriteNode {
    /**
     * Construct a new ConstantPathOperatorWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {ConstantPathNode} target
     * @param {Location} binaryOperatorLoc
     * @param {Node} value
     * @param {string} binaryOperator
     */
    constructor(nodeID: number, location: Location, flags: number, target: ConstantPathNode, binaryOperatorLoc: Location, value: Node, binaryOperator: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type ConstantPathNode
     */
    target: ConstantPathNode;
    /**
     * @type Location
     */
    binaryOperatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type string
     */
    binaryOperator: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `||=` operator for assignment to a constant path.
 *
 *     Parent::Child ||= value
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class ConstantPathOrWriteNode {
    /**
     * Construct a new ConstantPathOrWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {ConstantPathNode} target
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, target: ConstantPathNode, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type ConstantPathNode
     */
    target: ConstantPathNode;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to a constant path in a context that doesn't have an explicit value.
 *
 *     Foo::Foo, Bar::Bar = baz
 *     ^^^^^^^^  ^^^^^^^^
 */
export class ConstantPathTargetNode {
    /**
     * Construct a new ConstantPathTargetNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} parent
     * @param {string | null} name
     * @param {Location} delimiterLoc
     * @param {Location} nameLoc
     */
    constructor(nodeID: number, location: Location, flags: number, parent: Node | null, name: string | null, delimiterLoc: Location, nameLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    parent: Node | null;
    /**
     * @type string | null
     */
    name: string | null;
    /**
     * @type Location
     */
    delimiterLoc: Location;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to a constant path.
 *
 *     ::Foo = 1
 *     ^^^^^^^^^
 *
 *     Foo::Bar = 1
 *     ^^^^^^^^^^^^
 *
 *     ::Foo::Bar = 1
 *     ^^^^^^^^^^^^^^
 */
export class ConstantPathWriteNode {
    /**
     * Construct a new ConstantPathWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {ConstantPathNode} target
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, target: ConstantPathNode, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type ConstantPathNode
     */
    target: ConstantPathNode;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents referencing a constant.
 *
 *     Foo
 *     ^^^
 */
export class ConstantReadNode {
    /**
     * Construct a new ConstantReadNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to a constant in a context that doesn't have an explicit value.
 *
 *     Foo, Bar = baz
 *     ^^^  ^^^
 */
export class ConstantTargetNode {
    /**
     * Construct a new ConstantTargetNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to a constant.
 *
 *     Foo = 1
 *     ^^^^^^^
 */
export class ConstantWriteNode {
    /**
     * Construct a new ConstantWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Node} value
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, value: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a method definition.
 *
 *     def method
 *     end
 *     ^^^^^^^^^^
 */
export class DefNode {
    /**
     * Construct a new DefNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Node | null} receiver
     * @param {ParametersNode | null} parameters
     * @param {Node | null} body
     * @param {string[]} locals
     * @param {Location} defKeywordLoc
     * @param {Location | null} operatorLoc
     * @param {Location | null} lparenLoc
     * @param {Location | null} rparenLoc
     * @param {Location | null} equalLoc
     * @param {Location | null} endKeywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, receiver: Node | null, parameters: ParametersNode | null, body: Node | null, locals: string[], defKeywordLoc: Location, operatorLoc: Location | null, lparenLoc: Location | null, rparenLoc: Location | null, equalLoc: Location | null, endKeywordLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Node | null
     */
    receiver: Node | null;
    /**
     * @type ParametersNode | null
     */
    parameters: ParametersNode | null;
    /**
     * @type Node | null
     */
    body: Node | null;
    /**
     * @type string[]
     */
    locals: string[];
    /**
     * @type Location
     */
    defKeywordLoc: Location;
    /**
     * @type Location | null
     */
    operatorLoc: Location | null;
    /**
     * @type Location | null
     */
    lparenLoc: Location | null;
    /**
     * @type Location | null
     */
    rparenLoc: Location | null;
    /**
     * @type Location | null
     */
    equalLoc: Location | null;
    /**
     * @type Location | null
     */
    endKeywordLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `defined?` keyword.
 *
 *     defined?(a)
 *     ^^^^^^^^^^^
 */
export class DefinedNode {
    /**
     * Construct a new DefinedNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location | null} lparenLoc
     * @param {Node} value
     * @param {Location | null} rparenLoc
     * @param {Location} keywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, lparenLoc: Location | null, value: Node, rparenLoc: Location | null, keywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location | null
     */
    lparenLoc: Location | null;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type Location | null
     */
    rparenLoc: Location | null;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an `else` clause in a `case`, `if`, or `unless` statement.
 *
 *     if a then b else c end
 *                 ^^^^^^^^^^
 */
export class ElseNode {
    /**
     * Construct a new ElseNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} elseKeywordLoc
     * @param {StatementsNode | null} statements
     * @param {Location | null} endKeywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, elseKeywordLoc: Location, statements: StatementsNode | null, endKeywordLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    elseKeywordLoc: Location;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type Location | null
     */
    endKeywordLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an interpolated set of statements.
 *
 *     "foo #{bar}"
 *          ^^^^^^
 */
export class EmbeddedStatementsNode {
    /**
     * Construct a new EmbeddedStatementsNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} openingLoc
     * @param {StatementsNode | null} statements
     * @param {Location} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location, statements: StatementsNode | null, closingLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an interpolated variable.
 *
 *     "foo #@bar"
 *          ^^^^^
 */
export class EmbeddedVariableNode {
    /**
     * Construct a new EmbeddedVariableNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} operatorLoc
     * @param {Node} variable
     */
    constructor(nodeID: number, location: Location, flags: number, operatorLoc: Location, variable: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    variable: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an `ensure` clause in a `begin` statement.
 *
 *     begin
 *       foo
 *     ensure
 *     ^^^^^^
 *       bar
 *     end
 */
export class EnsureNode {
    /**
     * Construct a new EnsureNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} ensureKeywordLoc
     * @param {StatementsNode | null} statements
     * @param {Location} endKeywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, ensureKeywordLoc: Location, statements: StatementsNode | null, endKeywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    ensureKeywordLoc: Location;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type Location
     */
    endKeywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the literal `false` keyword.
 *
 *     false
 *     ^^^^^
 */
export class FalseNode {
    /**
     * Construct a new FalseNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a find pattern in pattern matching.
 *
 *     foo in *bar, baz, *qux
 *            ^^^^^^^^^^^^^^^
 *
 *     foo in [*bar, baz, *qux]
 *            ^^^^^^^^^^^^^^^^^
 *
 *     foo in Foo(*bar, baz, *qux)
 *            ^^^^^^^^^^^^^^^^^^^^
 */
export class FindPatternNode {
    /**
     * Construct a new FindPatternNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} constant
     * @param {SplatNode} left
     * @param {Node[]} requireds
     * @param {Node} right
     * @param {Location | null} openingLoc
     * @param {Location | null} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, constant: Node | null, left: SplatNode, requireds: Node[], right: Node, openingLoc: Location | null, closingLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    constant: Node | null;
    /**
     * @type SplatNode
     */
    left: SplatNode;
    /**
     * @type Node[]
     */
    requireds: Node[];
    /**
     * @type Node
     */
    right: Node;
    /**
     * @type Location | null
     */
    openingLoc: Location | null;
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `..` or `...` operators to create flip flops.
 *
 *     baz if foo .. bar
 *            ^^^^^^^^^^
 */
export class FlipFlopNode {
    /**
     * Construct a new FlipFlopNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} left
     * @param {Node | null} right
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, left: Node | null, right: Node | null, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    left: Node | null;
    /**
     * @type Node | null
     */
    right: Node | null;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * True if this node has the EXCLUDE_END flag.
     *
     * @returns {boolean}
     */
    isExcludeEnd(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a floating point number literal.
 *
 *     1.0
 *     ^^^
 */
export class FloatNode {
    /**
     * Construct a new FloatNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {number} value
     */
    constructor(nodeID: number, location: Location, flags: number, value: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type number
     */
    value: number;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `for` keyword.
 *
 *     for i in a end
 *     ^^^^^^^^^^^^^^
 */
export class ForNode {
    /**
     * Construct a new ForNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} index
     * @param {Node} collection
     * @param {StatementsNode | null} statements
     * @param {Location} forKeywordLoc
     * @param {Location} inKeywordLoc
     * @param {Location | null} doKeywordLoc
     * @param {Location} endKeywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, index: Node, collection: Node, statements: StatementsNode | null, forKeywordLoc: Location, inKeywordLoc: Location, doKeywordLoc: Location | null, endKeywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    index: Node;
    /**
     * @type Node
     */
    collection: Node;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type Location
     */
    forKeywordLoc: Location;
    /**
     * @type Location
     */
    inKeywordLoc: Location;
    /**
     * @type Location | null
     */
    doKeywordLoc: Location | null;
    /**
     * @type Location
     */
    endKeywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents forwarding all arguments to this method to another method.
 *
 *     def foo(...)
 *       bar(...)
 *           ^^^
 *     end
 */
export class ForwardingArgumentsNode {
    /**
     * Construct a new ForwardingArgumentsNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the forwarding parameter in a method, block, or lambda declaration.
 *
 *     def foo(...)
 *             ^^^
 *     end
 */
export class ForwardingParameterNode {
    /**
     * Construct a new ForwardingParameterNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `super` keyword without parentheses or arguments.
 *
 *     super
 *     ^^^^^
 */
export class ForwardingSuperNode {
    /**
     * Construct a new ForwardingSuperNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {BlockNode | null} block
     */
    constructor(nodeID: number, location: Location, flags: number, block: BlockNode | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type BlockNode | null
     */
    block: BlockNode | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `&&=` operator for assignment to a global variable.
 *
 *     $target &&= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class GlobalVariableAndWriteNode {
    /**
     * Construct a new GlobalVariableAndWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents assigning to a global variable using an operator that isn't `=`.
 *
 *     $target += value
 *     ^^^^^^^^^^^^^^^^
 */
export class GlobalVariableOperatorWriteNode {
    /**
     * Construct a new GlobalVariableOperatorWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} binaryOperatorLoc
     * @param {Node} value
     * @param {string} binaryOperator
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, binaryOperatorLoc: Location, value: Node, binaryOperator: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    binaryOperatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type string
     */
    binaryOperator: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `||=` operator for assignment to a global variable.
 *
 *     $target ||= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class GlobalVariableOrWriteNode {
    /**
     * Construct a new GlobalVariableOrWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents referencing a global variable.
 *
 *     $foo
 *     ^^^^
 */
export class GlobalVariableReadNode {
    /**
     * Construct a new GlobalVariableReadNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to a global variable in a context that doesn't have an explicit value.
 *
 *     $foo, $bar = baz
 *     ^^^^  ^^^^
 */
export class GlobalVariableTargetNode {
    /**
     * Construct a new GlobalVariableTargetNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to a global variable.
 *
 *     $foo = 1
 *     ^^^^^^^^
 */
export class GlobalVariableWriteNode {
    /**
     * Construct a new GlobalVariableWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Node} value
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, value: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a hash literal.
 *
 *     { a => b }
 *     ^^^^^^^^^^
 */
export class HashNode {
    /**
     * Construct a new HashNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} openingLoc
     * @param {Node[]} elements
     * @param {Location} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location, elements: Node[], closingLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Node[]
     */
    elements: Node[];
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a hash pattern in pattern matching.
 *
 *     foo => { a: 1, b: 2 }
 *            ^^^^^^^^^^^^^^
 *
 *     foo => { a: 1, b: 2, **c }
 *            ^^^^^^^^^^^^^^^^^^^
 */
export class HashPatternNode {
    /**
     * Construct a new HashPatternNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} constant
     * @param {Node[]} elements
     * @param {Node | null} rest
     * @param {Location | null} openingLoc
     * @param {Location | null} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, constant: Node | null, elements: Node[], rest: Node | null, openingLoc: Location | null, closingLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    constant: Node | null;
    /**
     * @type Node[]
     */
    elements: Node[];
    /**
     * @type Node | null
     */
    rest: Node | null;
    /**
     * @type Location | null
     */
    openingLoc: Location | null;
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.
 *
 *     bar if foo
 *     ^^^^^^^^^^
 *
 *     if foo then bar end
 *     ^^^^^^^^^^^^^^^^^^^
 *
 *     foo ? bar : baz
 *     ^^^^^^^^^^^^^^^
 */
export class IfNode {
    /**
     * Construct a new IfNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location | null} ifKeywordLoc
     * @param {Node} predicate
     * @param {Location | null} thenKeywordLoc
     * @param {StatementsNode | null} statements
     * @param {Node | null} subsequent
     * @param {Location | null} endKeywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, ifKeywordLoc: Location | null, predicate: Node, thenKeywordLoc: Location | null, statements: StatementsNode | null, subsequent: Node | null, endKeywordLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location | null
     */
    ifKeywordLoc: Location | null;
    /**
     * @type Node
     */
    predicate: Node;
    /**
     * @type Location | null
     */
    thenKeywordLoc: Location | null;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type Node | null
     */
    subsequent: Node | null;
    /**
     * @type Location | null
     */
    endKeywordLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an imaginary number literal.
 *
 *     1.0i
 *     ^^^^
 */
export class ImaginaryNode {
    /**
     * Construct a new ImaginaryNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} numeric
     */
    constructor(nodeID: number, location: Location, flags: number, numeric: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    numeric: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.
 *
 *     { foo: }
 *       ^^^^
 *
 *     { Foo: }
 *       ^^^^
 *
 *     foo in { bar: }
 *              ^^^^
 */
export class ImplicitNode {
    /**
     * Construct a new ImplicitNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents using a trailing comma to indicate an implicit rest parameter.
 *
 *     foo { |bar,| }
 *               ^
 *
 *     foo in [bar,]
 *                ^
 *
 *     for foo, in bar do end
 *            ^
 *
 *     foo, = bar
 *        ^
 */
export class ImplicitRestNode {
    /**
     * Construct a new ImplicitRestNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `in` keyword in a case statement.
 *
 *     case a; in b then c end
 *             ^^^^^^^^^^^
 */
export class InNode {
    /**
     * Construct a new InNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} pattern
     * @param {StatementsNode | null} statements
     * @param {Location} inLoc
     * @param {Location | null} thenLoc
     */
    constructor(nodeID: number, location: Location, flags: number, pattern: Node, statements: StatementsNode | null, inLoc: Location, thenLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    pattern: Node;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type Location
     */
    inLoc: Location;
    /**
     * @type Location | null
     */
    thenLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `&&=` operator on a call to the `[]` method.
 *
 *     foo.bar[baz] &&= value
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class IndexAndWriteNode {
    /**
     * Construct a new IndexAndWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} receiver
     * @param {Location | null} callOperatorLoc
     * @param {Location} openingLoc
     * @param {ArgumentsNode | null} arguments_
     * @param {Location} closingLoc
     * @param {BlockArgumentNode | null} block
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, receiver: Node | null, callOperatorLoc: Location | null, openingLoc: Location, arguments_: ArgumentsNode | null, closingLoc: Location, block: BlockArgumentNode | null, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    receiver: Node | null;
    /**
     * @type Location | null
     */
    callOperatorLoc: Location | null;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type ArgumentsNode | null
     */
    arguments_: ArgumentsNode | null;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * @type BlockArgumentNode | null
     */
    block: BlockArgumentNode | null;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * True if this node has the SAFE_NAVIGATION flag.
     *
     * @returns {boolean}
     */
    isSafeNavigation(): boolean;
    /**
     * True if this node has the VARIABLE_CALL flag.
     *
     * @returns {boolean}
     */
    isVariableCall(): boolean;
    /**
     * True if this node has the ATTRIBUTE_WRITE flag.
     *
     * @returns {boolean}
     */
    isAttributeWrite(): boolean;
    /**
     * True if this node has the IGNORE_VISIBILITY flag.
     *
     * @returns {boolean}
     */
    isIgnoreVisibility(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of an assignment operator on a call to `[]`.
 *
 *     foo.bar[baz] += value
 *     ^^^^^^^^^^^^^^^^^^^^^
 */
export class IndexOperatorWriteNode {
    /**
     * Construct a new IndexOperatorWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} receiver
     * @param {Location | null} callOperatorLoc
     * @param {Location} openingLoc
     * @param {ArgumentsNode | null} arguments_
     * @param {Location} closingLoc
     * @param {BlockArgumentNode | null} block
     * @param {string} binaryOperator
     * @param {Location} binaryOperatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, receiver: Node | null, callOperatorLoc: Location | null, openingLoc: Location, arguments_: ArgumentsNode | null, closingLoc: Location, block: BlockArgumentNode | null, binaryOperator: string, binaryOperatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    receiver: Node | null;
    /**
     * @type Location | null
     */
    callOperatorLoc: Location | null;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type ArgumentsNode | null
     */
    arguments_: ArgumentsNode | null;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * @type BlockArgumentNode | null
     */
    block: BlockArgumentNode | null;
    /**
     * @type string
     */
    binaryOperator: string;
    /**
     * @type Location
     */
    binaryOperatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * True if this node has the SAFE_NAVIGATION flag.
     *
     * @returns {boolean}
     */
    isSafeNavigation(): boolean;
    /**
     * True if this node has the VARIABLE_CALL flag.
     *
     * @returns {boolean}
     */
    isVariableCall(): boolean;
    /**
     * True if this node has the ATTRIBUTE_WRITE flag.
     *
     * @returns {boolean}
     */
    isAttributeWrite(): boolean;
    /**
     * True if this node has the IGNORE_VISIBILITY flag.
     *
     * @returns {boolean}
     */
    isIgnoreVisibility(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `||=` operator on a call to `[]`.
 *
 *     foo.bar[baz] ||= value
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class IndexOrWriteNode {
    /**
     * Construct a new IndexOrWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} receiver
     * @param {Location | null} callOperatorLoc
     * @param {Location} openingLoc
     * @param {ArgumentsNode | null} arguments_
     * @param {Location} closingLoc
     * @param {BlockArgumentNode | null} block
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, receiver: Node | null, callOperatorLoc: Location | null, openingLoc: Location, arguments_: ArgumentsNode | null, closingLoc: Location, block: BlockArgumentNode | null, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    receiver: Node | null;
    /**
     * @type Location | null
     */
    callOperatorLoc: Location | null;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type ArgumentsNode | null
     */
    arguments_: ArgumentsNode | null;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * @type BlockArgumentNode | null
     */
    block: BlockArgumentNode | null;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * True if this node has the SAFE_NAVIGATION flag.
     *
     * @returns {boolean}
     */
    isSafeNavigation(): boolean;
    /**
     * True if this node has the VARIABLE_CALL flag.
     *
     * @returns {boolean}
     */
    isVariableCall(): boolean;
    /**
     * True if this node has the ATTRIBUTE_WRITE flag.
     *
     * @returns {boolean}
     */
    isAttributeWrite(): boolean;
    /**
     * True if this node has the IGNORE_VISIBILITY flag.
     *
     * @returns {boolean}
     */
    isIgnoreVisibility(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents assigning to an index.
 *
 *     foo[bar], = 1
 *     ^^^^^^^^
 *
 *     begin
 *     rescue => foo[bar]
 *               ^^^^^^^^
 *     end
 *
 *     for foo[bar] in baz do end
 *         ^^^^^^^^
 */
export class IndexTargetNode {
    /**
     * Construct a new IndexTargetNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} receiver
     * @param {Location} openingLoc
     * @param {ArgumentsNode | null} arguments_
     * @param {Location} closingLoc
     * @param {BlockArgumentNode | null} block
     */
    constructor(nodeID: number, location: Location, flags: number, receiver: Node, openingLoc: Location, arguments_: ArgumentsNode | null, closingLoc: Location, block: BlockArgumentNode | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    receiver: Node;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type ArgumentsNode | null
     */
    arguments_: ArgumentsNode | null;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * @type BlockArgumentNode | null
     */
    block: BlockArgumentNode | null;
    /**
     * True if this node has the SAFE_NAVIGATION flag.
     *
     * @returns {boolean}
     */
    isSafeNavigation(): boolean;
    /**
     * True if this node has the VARIABLE_CALL flag.
     *
     * @returns {boolean}
     */
    isVariableCall(): boolean;
    /**
     * True if this node has the ATTRIBUTE_WRITE flag.
     *
     * @returns {boolean}
     */
    isAttributeWrite(): boolean;
    /**
     * True if this node has the IGNORE_VISIBILITY flag.
     *
     * @returns {boolean}
     */
    isIgnoreVisibility(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `&&=` operator for assignment to an instance variable.
 *
 *     @target &&= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class InstanceVariableAndWriteNode {
    /**
     * Construct a new InstanceVariableAndWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents assigning to an instance variable using an operator that isn't `=`.
 *
 *     @target += value
 *     ^^^^^^^^^^^^^^^^
 */
export class InstanceVariableOperatorWriteNode {
    /**
     * Construct a new InstanceVariableOperatorWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} binaryOperatorLoc
     * @param {Node} value
     * @param {string} binaryOperator
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, binaryOperatorLoc: Location, value: Node, binaryOperator: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    binaryOperatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type string
     */
    binaryOperator: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `||=` operator for assignment to an instance variable.
 *
 *     @target ||= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class InstanceVariableOrWriteNode {
    /**
     * Construct a new InstanceVariableOrWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents referencing an instance variable.
 *
 *     @foo
 *     ^^^^
 */
export class InstanceVariableReadNode {
    /**
     * Construct a new InstanceVariableReadNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to an instance variable in a context that doesn't have an explicit value.
 *
 *     @foo, @bar = baz
 *     ^^^^  ^^^^
 */
export class InstanceVariableTargetNode {
    /**
     * Construct a new InstanceVariableTargetNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to an instance variable.
 *
 *     @foo = 1
 *     ^^^^^^^^
 */
export class InstanceVariableWriteNode {
    /**
     * Construct a new InstanceVariableWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Node} value
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, value: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an integer number literal.
 *
 *     1
 *     ^
 */
export class IntegerNode {
    /**
     * Construct a new IntegerNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {number} value
     */
    constructor(nodeID: number, location: Location, flags: number, value: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type number
     */
    value: number;
    /**
     * True if this node has the BINARY flag.
     *
     * @returns {boolean}
     */
    isBinary(): boolean;
    /**
     * True if this node has the DECIMAL flag.
     *
     * @returns {boolean}
     */
    isDecimal(): boolean;
    /**
     * True if this node has the OCTAL flag.
     *
     * @returns {boolean}
     */
    isOctal(): boolean;
    /**
     * True if this node has the HEXADECIMAL flag.
     *
     * @returns {boolean}
     */
    isHexadecimal(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.
 *
 *     if /foo #{bar} baz/ then end
 *        ^^^^^^^^^^^^^^^^
 */
export class InterpolatedMatchLastLineNode {
    /**
     * Construct a new InterpolatedMatchLastLineNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} openingLoc
     * @param {Node[]} parts
     * @param {Location} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location, parts: Node[], closingLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Node[]
     */
    parts: Node[];
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * True if this node has the IGNORE_CASE flag.
     *
     * @returns {boolean}
     */
    isIgnoreCase(): boolean;
    /**
     * True if this node has the EXTENDED flag.
     *
     * @returns {boolean}
     */
    isExtended(): boolean;
    /**
     * True if this node has the MULTI_LINE flag.
     *
     * @returns {boolean}
     */
    isMultiLine(): boolean;
    /**
     * True if this node has the ONCE flag.
     *
     * @returns {boolean}
     */
    isOnce(): boolean;
    /**
     * True if this node has the EUC_JP flag.
     *
     * @returns {boolean}
     */
    isEucJp(): boolean;
    /**
     * True if this node has the ASCII_8BIT flag.
     *
     * @returns {boolean}
     */
    isAscii8bit(): boolean;
    /**
     * True if this node has the WINDOWS_31J flag.
     *
     * @returns {boolean}
     */
    isWindows31j(): boolean;
    /**
     * True if this node has the UTF_8 flag.
     *
     * @returns {boolean}
     */
    isUtf8(): boolean;
    /**
     * True if this node has the FORCED_UTF8_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUtf8Encoding(): boolean;
    /**
     * True if this node has the FORCED_BINARY_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedBinaryEncoding(): boolean;
    /**
     * True if this node has the FORCED_US_ASCII_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUsAsciiEncoding(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a regular expression literal that contains interpolation.
 *
 *     /foo #{bar} baz/
 *     ^^^^^^^^^^^^^^^^
 */
export class InterpolatedRegularExpressionNode {
    /**
     * Construct a new InterpolatedRegularExpressionNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} openingLoc
     * @param {Node[]} parts
     * @param {Location} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location, parts: Node[], closingLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Node[]
     */
    parts: Node[];
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * True if this node has the IGNORE_CASE flag.
     *
     * @returns {boolean}
     */
    isIgnoreCase(): boolean;
    /**
     * True if this node has the EXTENDED flag.
     *
     * @returns {boolean}
     */
    isExtended(): boolean;
    /**
     * True if this node has the MULTI_LINE flag.
     *
     * @returns {boolean}
     */
    isMultiLine(): boolean;
    /**
     * True if this node has the ONCE flag.
     *
     * @returns {boolean}
     */
    isOnce(): boolean;
    /**
     * True if this node has the EUC_JP flag.
     *
     * @returns {boolean}
     */
    isEucJp(): boolean;
    /**
     * True if this node has the ASCII_8BIT flag.
     *
     * @returns {boolean}
     */
    isAscii8bit(): boolean;
    /**
     * True if this node has the WINDOWS_31J flag.
     *
     * @returns {boolean}
     */
    isWindows31j(): boolean;
    /**
     * True if this node has the UTF_8 flag.
     *
     * @returns {boolean}
     */
    isUtf8(): boolean;
    /**
     * True if this node has the FORCED_UTF8_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUtf8Encoding(): boolean;
    /**
     * True if this node has the FORCED_BINARY_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedBinaryEncoding(): boolean;
    /**
     * True if this node has the FORCED_US_ASCII_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUsAsciiEncoding(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a string literal that contains interpolation.
 *
 *     "foo #{bar} baz"
 *     ^^^^^^^^^^^^^^^^
 */
export class InterpolatedStringNode {
    /**
     * Construct a new InterpolatedStringNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location | null} openingLoc
     * @param {Node[]} parts
     * @param {Location | null} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location | null, parts: Node[], closingLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location | null
     */
    openingLoc: Location | null;
    /**
     * @type Node[]
     */
    parts: Node[];
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * True if this node has the FROZEN flag.
     *
     * @returns {boolean}
     */
    isFrozen(): boolean;
    /**
     * True if this node has the MUTABLE flag.
     *
     * @returns {boolean}
     */
    isMutable(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a symbol literal that contains interpolation.
 *
 *     :"foo #{bar} baz"
 *     ^^^^^^^^^^^^^^^^^
 */
export class InterpolatedSymbolNode {
    /**
     * Construct a new InterpolatedSymbolNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location | null} openingLoc
     * @param {Node[]} parts
     * @param {Location | null} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location | null, parts: Node[], closingLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location | null
     */
    openingLoc: Location | null;
    /**
     * @type Node[]
     */
    parts: Node[];
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an xstring literal that contains interpolation.
 *
 *     `foo #{bar} baz`
 *     ^^^^^^^^^^^^^^^^
 */
export class InterpolatedXStringNode {
    /**
     * Construct a new InterpolatedXStringNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} openingLoc
     * @param {Node[]} parts
     * @param {Location} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location, parts: Node[], closingLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Node[]
     */
    parts: Node[];
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents reading from the implicit `it` local variable.
 *
 *     -> { it }
 *          ^^
 */
export class ItLocalVariableReadNode {
    /**
     * Construct a new ItLocalVariableReadNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.
 *
 *     -> { it + it }
 *     ^^^^^^^^^^^^^^
 */
export class ItParametersNode {
    /**
     * Construct a new ItParametersNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a hash literal without opening and closing braces.
 *
 *     foo(a: b)
 *         ^^^^
 */
export class KeywordHashNode {
    /**
     * Construct a new KeywordHashNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node[]} elements
     */
    constructor(nodeID: number, location: Location, flags: number, elements: Node[]);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node[]
     */
    elements: Node[];
    /**
     * True if this node has the SYMBOL_KEYS flag.
     *
     * @returns {boolean}
     */
    isSymbolKeys(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a keyword rest parameter to a method, block, or lambda definition.
 *
 *     def a(**b)
 *           ^^^
 *     end
 */
export class KeywordRestParameterNode {
    /**
     * Construct a new KeywordRestParameterNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string | null} name
     * @param {Location | null} nameLoc
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, name: string | null, nameLoc: Location | null, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string | null
     */
    name: string | null;
    /**
     * @type Location | null
     */
    nameLoc: Location | null;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * True if this node has the REPEATED_PARAMETER flag.
     *
     * @returns {boolean}
     */
    isRepeatedParameter(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents using a lambda literal (not the lambda method call).
 *
 *     ->(value) { value * 2 }
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class LambdaNode {
    /**
     * Construct a new LambdaNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string[]} locals
     * @param {Location} operatorLoc
     * @param {Location} openingLoc
     * @param {Location} closingLoc
     * @param {Node | null} parameters
     * @param {Node | null} body
     */
    constructor(nodeID: number, location: Location, flags: number, locals: string[], operatorLoc: Location, openingLoc: Location, closingLoc: Location, parameters: Node | null, body: Node | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string[]
     */
    locals: string[];
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * @type Node | null
     */
    parameters: Node | null;
    /**
     * @type Node | null
     */
    body: Node | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `&&=` operator for assignment to a local variable.
 *
 *     target &&= value
 *     ^^^^^^^^^^^^^^^^
 */
export class LocalVariableAndWriteNode {
    /**
     * Construct a new LocalVariableAndWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     * @param {string} name
     * @param {number} depth
     */
    constructor(nodeID: number, location: Location, flags: number, nameLoc: Location, operatorLoc: Location, value: Node, name: string, depth: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type string
     */
    name: string;
    /**
     * @type number
     */
    depth: number;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents assigning to a local variable using an operator that isn't `=`.
 *
 *     target += value
 *     ^^^^^^^^^^^^^^^
 */
export class LocalVariableOperatorWriteNode {
    /**
     * Construct a new LocalVariableOperatorWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} nameLoc
     * @param {Location} binaryOperatorLoc
     * @param {Node} value
     * @param {string} name
     * @param {string} binaryOperator
     * @param {number} depth
     */
    constructor(nodeID: number, location: Location, flags: number, nameLoc: Location, binaryOperatorLoc: Location, value: Node, name: string, binaryOperator: string, depth: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    binaryOperatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type string
     */
    name: string;
    /**
     * @type string
     */
    binaryOperator: string;
    /**
     * @type number
     */
    depth: number;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `||=` operator for assignment to a local variable.
 *
 *     target ||= value
 *     ^^^^^^^^^^^^^^^^
 */
export class LocalVariableOrWriteNode {
    /**
     * Construct a new LocalVariableOrWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     * @param {string} name
     * @param {number} depth
     */
    constructor(nodeID: number, location: Location, flags: number, nameLoc: Location, operatorLoc: Location, value: Node, name: string, depth: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type string
     */
    name: string;
    /**
     * @type number
     */
    depth: number;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.
 *
 *     foo
 *     ^^^
 */
export class LocalVariableReadNode {
    /**
     * Construct a new LocalVariableReadNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {number} depth
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, depth: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type number
     */
    depth: number;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to a local variable in a context that doesn't have an explicit value.
 *
 *     foo, bar = baz
 *     ^^^  ^^^
 */
export class LocalVariableTargetNode {
    /**
     * Construct a new LocalVariableTargetNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {number} depth
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, depth: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type number
     */
    depth: number;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing to a local variable.
 *
 *     foo = 1
 *     ^^^^^^^
 */
export class LocalVariableWriteNode {
    /**
     * Construct a new LocalVariableWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {number} depth
     * @param {Location} nameLoc
     * @param {Node} value
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, depth: number, nameLoc: Location, value: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type number
     */
    depth: number;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.
 *
 *     if /foo/i then end
 *        ^^^^^^
 */
export class MatchLastLineNode {
    /**
     * Construct a new MatchLastLineNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} openingLoc
     * @param {Location} contentLoc
     * @param {Location} closingLoc
     * @param {RubyString} unescaped
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location, contentLoc: Location, closingLoc: Location, unescaped: RubyString);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Location
     */
    contentLoc: Location;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * @type RubyString
     */
    unescaped: RubyString;
    /**
     * True if this node has the IGNORE_CASE flag.
     *
     * @returns {boolean}
     */
    isIgnoreCase(): boolean;
    /**
     * True if this node has the EXTENDED flag.
     *
     * @returns {boolean}
     */
    isExtended(): boolean;
    /**
     * True if this node has the MULTI_LINE flag.
     *
     * @returns {boolean}
     */
    isMultiLine(): boolean;
    /**
     * True if this node has the ONCE flag.
     *
     * @returns {boolean}
     */
    isOnce(): boolean;
    /**
     * True if this node has the EUC_JP flag.
     *
     * @returns {boolean}
     */
    isEucJp(): boolean;
    /**
     * True if this node has the ASCII_8BIT flag.
     *
     * @returns {boolean}
     */
    isAscii8bit(): boolean;
    /**
     * True if this node has the WINDOWS_31J flag.
     *
     * @returns {boolean}
     */
    isWindows31j(): boolean;
    /**
     * True if this node has the UTF_8 flag.
     *
     * @returns {boolean}
     */
    isUtf8(): boolean;
    /**
     * True if this node has the FORCED_UTF8_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUtf8Encoding(): boolean;
    /**
     * True if this node has the FORCED_BINARY_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedBinaryEncoding(): boolean;
    /**
     * True if this node has the FORCED_US_ASCII_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUsAsciiEncoding(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the modifier `in` operator.
 *
 *     foo in bar
 *     ^^^^^^^^^^
 */
export class MatchPredicateNode {
    /**
     * Construct a new MatchPredicateNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} value
     * @param {Node} pattern
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, value: Node, pattern: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type Node
     */
    pattern: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `=>` operator.
 *
 *     foo => bar
 *     ^^^^^^^^^^
 */
export class MatchRequiredNode {
    /**
     * Construct a new MatchRequiredNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} value
     * @param {Node} pattern
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, value: Node, pattern: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * @type Node
     */
    pattern: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents writing local variables using a regular expression match with named capture groups.
 *
 *     /(?<foo>bar)/ =~ baz
 *     ^^^^^^^^^^^^^^^^^^^^
 */
export class MatchWriteNode {
    /**
     * Construct a new MatchWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {CallNode} call
     * @param {Node[]} targets
     */
    constructor(nodeID: number, location: Location, flags: number, call: CallNode, targets: Node[]);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type CallNode
     */
    call: CallNode;
    /**
     * @type Node[]
     */
    targets: Node[];
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a node that is missing from the source and results in a syntax error.
 */
export class MissingNode {
    /**
     * Construct a new MissingNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a module declaration involving the `module` keyword.
 *
 *     module Foo end
 *     ^^^^^^^^^^^^^^
 */
export class ModuleNode {
    /**
     * Construct a new ModuleNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string[]} locals
     * @param {Location} moduleKeywordLoc
     * @param {Node} constantPath
     * @param {Node | null} body
     * @param {Location} endKeywordLoc
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, locals: string[], moduleKeywordLoc: Location, constantPath: Node, body: Node | null, endKeywordLoc: Location, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string[]
     */
    locals: string[];
    /**
     * @type Location
     */
    moduleKeywordLoc: Location;
    /**
     * @type Node
     */
    constantPath: Node;
    /**
     * @type Node | null
     */
    body: Node | null;
    /**
     * @type Location
     */
    endKeywordLoc: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a multi-target expression.
 *
 *     a, (b, c) = 1, 2, 3
 *        ^^^^^^
 *
 * This can be a part of `MultiWriteNode` as above, or the target of a `for` loop
 *
 *     for a, b in [[1, 2], [3, 4]]
 *         ^^^^
 */
export class MultiTargetNode {
    /**
     * Construct a new MultiTargetNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node[]} lefts
     * @param {Node | null} rest
     * @param {Node[]} rights
     * @param {Location | null} lparenLoc
     * @param {Location | null} rparenLoc
     */
    constructor(nodeID: number, location: Location, flags: number, lefts: Node[], rest: Node | null, rights: Node[], lparenLoc: Location | null, rparenLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node[]
     */
    lefts: Node[];
    /**
     * @type Node | null
     */
    rest: Node | null;
    /**
     * @type Node[]
     */
    rights: Node[];
    /**
     * @type Location | null
     */
    lparenLoc: Location | null;
    /**
     * @type Location | null
     */
    rparenLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a write to a multi-target expression.
 *
 *     a, b, c = 1, 2, 3
 *     ^^^^^^^^^^^^^^^^^
 */
export class MultiWriteNode {
    /**
     * Construct a new MultiWriteNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node[]} lefts
     * @param {Node | null} rest
     * @param {Node[]} rights
     * @param {Location | null} lparenLoc
     * @param {Location | null} rparenLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, lefts: Node[], rest: Node | null, rights: Node[], lparenLoc: Location | null, rparenLoc: Location | null, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node[]
     */
    lefts: Node[];
    /**
     * @type Node | null
     */
    rest: Node | null;
    /**
     * @type Node[]
     */
    rights: Node[];
    /**
     * @type Location | null
     */
    lparenLoc: Location | null;
    /**
     * @type Location | null
     */
    rparenLoc: Location | null;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `next` keyword.
 *
 *     next 1
 *     ^^^^^^
 */
export class NextNode {
    /**
     * Construct a new NextNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {ArgumentsNode | null} arguments_
     * @param {Location} keywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, arguments_: ArgumentsNode | null, keywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type ArgumentsNode | null
     */
    arguments_: ArgumentsNode | null;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `nil` keyword.
 *
 *     nil
 *     ^^^
 */
export class NilNode {
    /**
     * Construct a new NilNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of `**nil` inside method arguments.
 *
 *     def a(**nil)
 *           ^^^^^
 *     end
 */
export class NoKeywordsParameterNode {
    /**
     * Construct a new NoKeywordsParameterNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} operatorLoc
     * @param {Location} keywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, operatorLoc: Location, keywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.
 *
 *     -> { _1 + _2 }
 *     ^^^^^^^^^^^^^^
 */
export class NumberedParametersNode {
    /**
     * Construct a new NumberedParametersNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {number} maximum
     */
    constructor(nodeID: number, location: Location, flags: number, maximum: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type number
     */
    maximum: number;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents reading a numbered reference to a capture in the previous match.
 *
 *     $1
 *     ^^
 */
export class NumberedReferenceReadNode {
    /**
     * Construct a new NumberedReferenceReadNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {number} number
     */
    constructor(nodeID: number, location: Location, flags: number, number: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type number
     */
    number: number;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an optional keyword parameter to a method, block, or lambda definition.
 *
 *     def a(b: 1)
 *           ^^^^
 *     end
 */
export class OptionalKeywordParameterNode {
    /**
     * Construct a new OptionalKeywordParameterNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * True if this node has the REPEATED_PARAMETER flag.
     *
     * @returns {boolean}
     */
    isRepeatedParameter(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an optional parameter to a method, block, or lambda definition.
 *
 *     def a(b = 1)
 *           ^^^^^
 *     end
 */
export class OptionalParameterNode {
    /**
     * Construct a new OptionalParameterNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     * @param {Location} operatorLoc
     * @param {Node} value
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location, operatorLoc: Location, value: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    value: Node;
    /**
     * True if this node has the REPEATED_PARAMETER flag.
     *
     * @returns {boolean}
     */
    isRepeatedParameter(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `||` operator or the `or` keyword.
 *
 *     left or right
 *     ^^^^^^^^^^^^^
 */
export class OrNode {
    /**
     * Construct a new OrNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} left
     * @param {Node} right
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, left: Node, right: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    left: Node;
    /**
     * @type Node
     */
    right: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the list of parameters on a method, block, or lambda definition.
 *
 *     def a(b, c, d)
 *           ^^^^^^^
 *     end
 */
export class ParametersNode {
    /**
     * Construct a new ParametersNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node[]} requireds
     * @param {Node[]} optionals
     * @param {Node | null} rest
     * @param {Node[]} posts
     * @param {Node[]} keywords
     * @param {Node | null} keywordRest
     * @param {BlockParameterNode | null} block
     */
    constructor(nodeID: number, location: Location, flags: number, requireds: Node[], optionals: Node[], rest: Node | null, posts: Node[], keywords: Node[], keywordRest: Node | null, block: BlockParameterNode | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node[]
     */
    requireds: Node[];
    /**
     * @type Node[]
     */
    optionals: Node[];
    /**
     * @type Node | null
     */
    rest: Node | null;
    /**
     * @type Node[]
     */
    posts: Node[];
    /**
     * @type Node[]
     */
    keywords: Node[];
    /**
     * @type Node | null
     */
    keywordRest: Node | null;
    /**
     * @type BlockParameterNode | null
     */
    block: BlockParameterNode | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a parenthesized expression
 *
 *     (10 + 34)
 *     ^^^^^^^^^
 */
export class ParenthesesNode {
    /**
     * Construct a new ParenthesesNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} body
     * @param {Location} openingLoc
     * @param {Location} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, body: Node | null, openingLoc: Location, closingLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    body: Node | null;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `^` operator for pinning an expression in a pattern matching expression.
 *
 *     foo in ^(bar)
 *            ^^^^^^
 */
export class PinnedExpressionNode {
    /**
     * Construct a new PinnedExpressionNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} expression
     * @param {Location} operatorLoc
     * @param {Location} lparenLoc
     * @param {Location} rparenLoc
     */
    constructor(nodeID: number, location: Location, flags: number, expression: Node, operatorLoc: Location, lparenLoc: Location, rparenLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    expression: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Location
     */
    lparenLoc: Location;
    /**
     * @type Location
     */
    rparenLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `^` operator for pinning a variable in a pattern matching expression.
 *
 *     foo in ^bar
 *            ^^^^
 */
export class PinnedVariableNode {
    /**
     * Construct a new PinnedVariableNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} variable
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, variable: Node, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    variable: Node;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `END` keyword.
 *
 *     END { foo }
 *     ^^^^^^^^^^^
 */
export class PostExecutionNode {
    /**
     * Construct a new PostExecutionNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {StatementsNode | null} statements
     * @param {Location} keywordLoc
     * @param {Location} openingLoc
     * @param {Location} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, statements: StatementsNode | null, keywordLoc: Location, openingLoc: Location, closingLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `BEGIN` keyword.
 *
 *     BEGIN { foo }
 *     ^^^^^^^^^^^^^
 */
export class PreExecutionNode {
    /**
     * Construct a new PreExecutionNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {StatementsNode | null} statements
     * @param {Location} keywordLoc
     * @param {Location} openingLoc
     * @param {Location} closingLoc
     */
    constructor(nodeID: number, location: Location, flags: number, statements: StatementsNode | null, keywordLoc: Location, openingLoc: Location, closingLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * The top level node of any parse tree.
 */
export class ProgramNode {
    /**
     * Construct a new ProgramNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string[]} locals
     * @param {StatementsNode} statements
     */
    constructor(nodeID: number, location: Location, flags: number, locals: string[], statements: StatementsNode);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string[]
     */
    locals: string[];
    /**
     * @type StatementsNode
     */
    statements: StatementsNode;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `..` or `...` operators.
 *
 *     1..2
 *     ^^^^
 *
 *     c if a =~ /left/ ... b =~ /right/
 *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 */
export class RangeNode {
    /**
     * Construct a new RangeNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node | null} left
     * @param {Node | null} right
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, left: Node | null, right: Node | null, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node | null
     */
    left: Node | null;
    /**
     * @type Node | null
     */
    right: Node | null;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * True if this node has the EXCLUDE_END flag.
     *
     * @returns {boolean}
     */
    isExcludeEnd(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a rational number literal.
 *
 *     1.0r
 *     ^^^^
 */
export class RationalNode {
    /**
     * Construct a new RationalNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {number} numerator
     * @param {number} denominator
     */
    constructor(nodeID: number, location: Location, flags: number, numerator: number, denominator: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type number
     */
    numerator: number;
    /**
     * @type number
     */
    denominator: number;
    /**
     * True if this node has the BINARY flag.
     *
     * @returns {boolean}
     */
    isBinary(): boolean;
    /**
     * True if this node has the DECIMAL flag.
     *
     * @returns {boolean}
     */
    isDecimal(): boolean;
    /**
     * True if this node has the OCTAL flag.
     *
     * @returns {boolean}
     */
    isOctal(): boolean;
    /**
     * True if this node has the HEXADECIMAL flag.
     *
     * @returns {boolean}
     */
    isHexadecimal(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `redo` keyword.
 *
 *     redo
 *     ^^^^
 */
export class RedoNode {
    /**
     * Construct a new RedoNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a regular expression literal with no interpolation.
 *
 *     /foo/i
 *     ^^^^^^
 */
export class RegularExpressionNode {
    /**
     * Construct a new RegularExpressionNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} openingLoc
     * @param {Location} contentLoc
     * @param {Location} closingLoc
     * @param {RubyString} unescaped
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location, contentLoc: Location, closingLoc: Location, unescaped: RubyString);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Location
     */
    contentLoc: Location;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * @type RubyString
     */
    unescaped: RubyString;
    /**
     * True if this node has the IGNORE_CASE flag.
     *
     * @returns {boolean}
     */
    isIgnoreCase(): boolean;
    /**
     * True if this node has the EXTENDED flag.
     *
     * @returns {boolean}
     */
    isExtended(): boolean;
    /**
     * True if this node has the MULTI_LINE flag.
     *
     * @returns {boolean}
     */
    isMultiLine(): boolean;
    /**
     * True if this node has the ONCE flag.
     *
     * @returns {boolean}
     */
    isOnce(): boolean;
    /**
     * True if this node has the EUC_JP flag.
     *
     * @returns {boolean}
     */
    isEucJp(): boolean;
    /**
     * True if this node has the ASCII_8BIT flag.
     *
     * @returns {boolean}
     */
    isAscii8bit(): boolean;
    /**
     * True if this node has the WINDOWS_31J flag.
     *
     * @returns {boolean}
     */
    isWindows31j(): boolean;
    /**
     * True if this node has the UTF_8 flag.
     *
     * @returns {boolean}
     */
    isUtf8(): boolean;
    /**
     * True if this node has the FORCED_UTF8_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUtf8Encoding(): boolean;
    /**
     * True if this node has the FORCED_BINARY_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedBinaryEncoding(): boolean;
    /**
     * True if this node has the FORCED_US_ASCII_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUsAsciiEncoding(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a required keyword parameter to a method, block, or lambda definition.
 *
 *     def a(b: )
 *           ^^
 *     end
 */
export class RequiredKeywordParameterNode {
    /**
     * Construct a new RequiredKeywordParameterNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     * @param {Location} nameLoc
     */
    constructor(nodeID: number, location: Location, flags: number, name: string, nameLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * @type Location
     */
    nameLoc: Location;
    /**
     * True if this node has the REPEATED_PARAMETER flag.
     *
     * @returns {boolean}
     */
    isRepeatedParameter(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a required parameter to a method, block, or lambda definition.
 *
 *     def a(b)
 *           ^
 *     end
 */
export class RequiredParameterNode {
    /**
     * Construct a new RequiredParameterNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string} name
     */
    constructor(nodeID: number, location: Location, flags: number, name: string);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string
     */
    name: string;
    /**
     * True if this node has the REPEATED_PARAMETER flag.
     *
     * @returns {boolean}
     */
    isRepeatedParameter(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an expression modified with a rescue.
 *
 *     foo rescue nil
 *     ^^^^^^^^^^^^^^
 */
export class RescueModifierNode {
    /**
     * Construct a new RescueModifierNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} expression
     * @param {Location} keywordLoc
     * @param {Node} rescueExpression
     */
    constructor(nodeID: number, location: Location, flags: number, expression: Node, keywordLoc: Location, rescueExpression: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    expression: Node;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type Node
     */
    rescueExpression: Node;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a rescue statement.
 *
 *     begin
 *     rescue Foo, *splat, Bar => ex
 *       foo
 *     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 *     end
 *
 * `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `reference` field.
 */
export class RescueNode {
    /**
     * Construct a new RescueNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} keywordLoc
     * @param {Node[]} exceptions
     * @param {Location | null} operatorLoc
     * @param {Node | null} reference
     * @param {StatementsNode | null} statements
     * @param {RescueNode | null} subsequent
     */
    constructor(nodeID: number, location: Location, flags: number, keywordLoc: Location, exceptions: Node[], operatorLoc: Location | null, reference: Node | null, statements: StatementsNode | null, subsequent: RescueNode | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type Node[]
     */
    exceptions: Node[];
    /**
     * @type Location | null
     */
    operatorLoc: Location | null;
    /**
     * @type Node | null
     */
    reference: Node | null;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type RescueNode | null
     */
    subsequent: RescueNode | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a rest parameter to a method, block, or lambda definition.
 *
 *     def a(*b)
 *           ^^
 *     end
 */
export class RestParameterNode {
    /**
     * Construct a new RestParameterNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string | null} name
     * @param {Location | null} nameLoc
     * @param {Location} operatorLoc
     */
    constructor(nodeID: number, location: Location, flags: number, name: string | null, nameLoc: Location | null, operatorLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string | null
     */
    name: string | null;
    /**
     * @type Location | null
     */
    nameLoc: Location | null;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * True if this node has the REPEATED_PARAMETER flag.
     *
     * @returns {boolean}
     */
    isRepeatedParameter(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `retry` keyword.
 *
 *     retry
 *     ^^^^^
 */
export class RetryNode {
    /**
     * Construct a new RetryNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `return` keyword.
 *
 *     return 1
 *     ^^^^^^^^
 */
export class ReturnNode {
    /**
     * Construct a new ReturnNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} keywordLoc
     * @param {ArgumentsNode | null} arguments_
     */
    constructor(nodeID: number, location: Location, flags: number, keywordLoc: Location, arguments_: ArgumentsNode | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type ArgumentsNode | null
     */
    arguments_: ArgumentsNode | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the `self` keyword.
 *
 *     self
 *     ^^^^
 */
export class SelfNode {
    /**
     * Construct a new SelfNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.
 *
 *     # shareable_constant_value: literal
 *     C = { a: 1 }
 *     ^^^^^^^^^^^^
 */
export class ShareableConstantNode {
    /**
     * Construct a new ShareableConstantNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node} write
     */
    constructor(nodeID: number, location: Location, flags: number, write: Node);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node
     */
    write: Node;
    /**
     * True if this node has the LITERAL flag.
     *
     * @returns {boolean}
     */
    isLiteral(): boolean;
    /**
     * True if this node has the EXPERIMENTAL_EVERYTHING flag.
     *
     * @returns {boolean}
     */
    isExperimentalEverything(): boolean;
    /**
     * True if this node has the EXPERIMENTAL_COPY flag.
     *
     * @returns {boolean}
     */
    isExperimentalCopy(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a singleton class declaration involving the `class` keyword.
 *
 *     class << self end
 *     ^^^^^^^^^^^^^^^^^
 */
export class SingletonClassNode {
    /**
     * Construct a new SingletonClassNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {string[]} locals
     * @param {Location} classKeywordLoc
     * @param {Location} operatorLoc
     * @param {Node} expression
     * @param {Node | null} body
     * @param {Location} endKeywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, locals: string[], classKeywordLoc: Location, operatorLoc: Location, expression: Node, body: Node | null, endKeywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type string[]
     */
    locals: string[];
    /**
     * @type Location
     */
    classKeywordLoc: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node
     */
    expression: Node;
    /**
     * @type Node | null
     */
    body: Node | null;
    /**
     * @type Location
     */
    endKeywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `__ENCODING__` keyword.
 *
 *     __ENCODING__
 *     ^^^^^^^^^^^^
 */
export class SourceEncodingNode {
    /**
     * Construct a new SourceEncodingNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `__FILE__` keyword.
 *
 *     __FILE__
 *     ^^^^^^^^
 */
export class SourceFileNode {
    /**
     * Construct a new SourceFileNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {RubyString} filepath
     */
    constructor(nodeID: number, location: Location, flags: number, filepath: RubyString);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type RubyString
     */
    filepath: RubyString;
    /**
     * True if this node has the FORCED_UTF8_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUtf8Encoding(): boolean;
    /**
     * True if this node has the FORCED_BINARY_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedBinaryEncoding(): boolean;
    /**
     * True if this node has the FROZEN flag.
     *
     * @returns {boolean}
     */
    isFrozen(): boolean;
    /**
     * True if this node has the MUTABLE flag.
     *
     * @returns {boolean}
     */
    isMutable(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `__LINE__` keyword.
 *
 *     __LINE__
 *     ^^^^^^^^
 */
export class SourceLineNode {
    /**
     * Construct a new SourceLineNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the splat operator.
 *
 *     [*a]
 *      ^^
 */
export class SplatNode {
    /**
     * Construct a new SplatNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} operatorLoc
     * @param {Node | null} expression
     */
    constructor(nodeID: number, location: Location, flags: number, operatorLoc: Location, expression: Node | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    operatorLoc: Location;
    /**
     * @type Node | null
     */
    expression: Node | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a set of statements contained within some scope.
 *
 *     foo; bar; baz
 *     ^^^^^^^^^^^^^
 */
export class StatementsNode {
    /**
     * Construct a new StatementsNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node[]} body
     */
    constructor(nodeID: number, location: Location, flags: number, body: Node[]);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node[]
     */
    body: Node[];
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.
 *
 *     "foo"
 *     ^^^^^
 *
 *     %w[foo]
 *        ^^^
 *
 *     "foo #{bar} baz"
 *      ^^^^      ^^^^
 */
export class StringNode {
    /**
     * Construct a new StringNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location | null} openingLoc
     * @param {Location} contentLoc
     * @param {Location | null} closingLoc
     * @param {RubyString} unescaped
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location | null, contentLoc: Location, closingLoc: Location | null, unescaped: RubyString);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location | null
     */
    openingLoc: Location | null;
    /**
     * @type Location
     */
    contentLoc: Location;
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * @type RubyString
     */
    unescaped: RubyString;
    /**
     * True if this node has the FORCED_UTF8_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUtf8Encoding(): boolean;
    /**
     * True if this node has the FORCED_BINARY_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedBinaryEncoding(): boolean;
    /**
     * True if this node has the FROZEN flag.
     *
     * @returns {boolean}
     */
    isFrozen(): boolean;
    /**
     * True if this node has the MUTABLE flag.
     *
     * @returns {boolean}
     */
    isMutable(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `super` keyword with parentheses or arguments.
 *
 *     super()
 *     ^^^^^^^
 *
 *     super foo, bar
 *     ^^^^^^^^^^^^^^
 */
export class SuperNode {
    /**
     * Construct a new SuperNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} keywordLoc
     * @param {Location | null} lparenLoc
     * @param {ArgumentsNode | null} arguments_
     * @param {Location | null} rparenLoc
     * @param {Node | null} block
     */
    constructor(nodeID: number, location: Location, flags: number, keywordLoc: Location, lparenLoc: Location | null, arguments_: ArgumentsNode | null, rparenLoc: Location | null, block: Node | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type Location | null
     */
    lparenLoc: Location | null;
    /**
     * @type ArgumentsNode | null
     */
    arguments_: ArgumentsNode | null;
    /**
     * @type Location | null
     */
    rparenLoc: Location | null;
    /**
     * @type Node | null
     */
    block: Node | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents a symbol literal or a symbol contained within a `%i` list.
 *
 *     :foo
 *     ^^^^
 *
 *     %i[foo]
 *        ^^^
 */
export class SymbolNode {
    /**
     * Construct a new SymbolNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location | null} openingLoc
     * @param {Location | null} valueLoc
     * @param {Location | null} closingLoc
     * @param {RubyString} unescaped
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location | null, valueLoc: Location | null, closingLoc: Location | null, unescaped: RubyString);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location | null
     */
    openingLoc: Location | null;
    /**
     * @type Location | null
     */
    valueLoc: Location | null;
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * @type RubyString
     */
    unescaped: RubyString;
    /**
     * True if this node has the FORCED_UTF8_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUtf8Encoding(): boolean;
    /**
     * True if this node has the FORCED_BINARY_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedBinaryEncoding(): boolean;
    /**
     * True if this node has the FORCED_US_ASCII_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUsAsciiEncoding(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the literal `true` keyword.
 *
 *     true
 *     ^^^^
 */
export class TrueNode {
    /**
     * Construct a new TrueNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     */
    constructor(nodeID: number, location: Location, flags: number);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `undef` keyword.
 *
 *     undef :foo, :bar, :baz
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class UndefNode {
    /**
     * Construct a new UndefNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Node[]} names
     * @param {Location} keywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, names: Node[], keywordLoc: Location);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Node[]
     */
    names: Node[];
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `unless` keyword, either in the block form or the modifier form.
 *
 *     bar unless foo
 *     ^^^^^^^^^^^^^^
 *
 *     unless foo then bar end
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class UnlessNode {
    /**
     * Construct a new UnlessNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} keywordLoc
     * @param {Node} predicate
     * @param {Location | null} thenKeywordLoc
     * @param {StatementsNode | null} statements
     * @param {ElseNode | null} elseClause
     * @param {Location | null} endKeywordLoc
     */
    constructor(nodeID: number, location: Location, flags: number, keywordLoc: Location, predicate: Node, thenKeywordLoc: Location | null, statements: StatementsNode | null, elseClause: ElseNode | null, endKeywordLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type Node
     */
    predicate: Node;
    /**
     * @type Location | null
     */
    thenKeywordLoc: Location | null;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * @type ElseNode | null
     */
    elseClause: ElseNode | null;
    /**
     * @type Location | null
     */
    endKeywordLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `until` keyword, either in the block form or the modifier form.
 *
 *     bar until foo
 *     ^^^^^^^^^^^^^
 *
 *     until foo do bar end
 *     ^^^^^^^^^^^^^^^^^^^^
 */
export class UntilNode {
    /**
     * Construct a new UntilNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} keywordLoc
     * @param {Location | null} doKeywordLoc
     * @param {Location | null} closingLoc
     * @param {Node} predicate
     * @param {StatementsNode | null} statements
     */
    constructor(nodeID: number, location: Location, flags: number, keywordLoc: Location, doKeywordLoc: Location | null, closingLoc: Location | null, predicate: Node, statements: StatementsNode | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type Location | null
     */
    doKeywordLoc: Location | null;
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * @type Node
     */
    predicate: Node;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * True if this node has the BEGIN_MODIFIER flag.
     *
     * @returns {boolean}
     */
    isBeginModifier(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `when` keyword within a case statement.
 *
 *     case true
 *     when true
 *     ^^^^^^^^^
 *     end
 */
export class WhenNode {
    /**
     * Construct a new WhenNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} keywordLoc
     * @param {Node[]} conditions
     * @param {Location | null} thenKeywordLoc
     * @param {StatementsNode | null} statements
     */
    constructor(nodeID: number, location: Location, flags: number, keywordLoc: Location, conditions: Node[], thenKeywordLoc: Location | null, statements: StatementsNode | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type Node[]
     */
    conditions: Node[];
    /**
     * @type Location | null
     */
    thenKeywordLoc: Location | null;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `while` keyword, either in the block form or the modifier form.
 *
 *     bar while foo
 *     ^^^^^^^^^^^^^
 *
 *     while foo do bar end
 *     ^^^^^^^^^^^^^^^^^^^^
 */
export class WhileNode {
    /**
     * Construct a new WhileNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} keywordLoc
     * @param {Location | null} doKeywordLoc
     * @param {Location | null} closingLoc
     * @param {Node} predicate
     * @param {StatementsNode | null} statements
     */
    constructor(nodeID: number, location: Location, flags: number, keywordLoc: Location, doKeywordLoc: Location | null, closingLoc: Location | null, predicate: Node, statements: StatementsNode | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type Location | null
     */
    doKeywordLoc: Location | null;
    /**
     * @type Location | null
     */
    closingLoc: Location | null;
    /**
     * @type Node
     */
    predicate: Node;
    /**
     * @type StatementsNode | null
     */
    statements: StatementsNode | null;
    /**
     * True if this node has the BEGIN_MODIFIER flag.
     *
     * @returns {boolean}
     */
    isBeginModifier(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents an xstring literal with no interpolation.
 *
 *     `foo`
 *     ^^^^^
 */
export class XStringNode {
    /**
     * Construct a new XStringNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} openingLoc
     * @param {Location} contentLoc
     * @param {Location} closingLoc
     * @param {RubyString} unescaped
     */
    constructor(nodeID: number, location: Location, flags: number, openingLoc: Location, contentLoc: Location, closingLoc: Location, unescaped: RubyString);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    openingLoc: Location;
    /**
     * @type Location
     */
    contentLoc: Location;
    /**
     * @type Location
     */
    closingLoc: Location;
    /**
     * @type RubyString
     */
    unescaped: RubyString;
    /**
     * True if this node has the FORCED_UTF8_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedUtf8Encoding(): boolean;
    /**
     * True if this node has the FORCED_BINARY_ENCODING flag.
     *
     * @returns {boolean}
     */
    isForcedBinaryEncoding(): boolean;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * Represents the use of the `yield` keyword.
 *
 *     yield 1
 *     ^^^^^^^
 */
export class YieldNode {
    /**
     * Construct a new YieldNode.
     *
     * @param {number} nodeID
     * @param {Location} location
     * @param {number} flags
     * @param {Location} keywordLoc
     * @param {Location | null} lparenLoc
     * @param {ArgumentsNode | null} arguments_
     * @param {Location | null} rparenLoc
     */
    constructor(nodeID: number, location: Location, flags: number, keywordLoc: Location, lparenLoc: Location | null, arguments_: ArgumentsNode | null, rparenLoc: Location | null);
    /**
     * @type number
     */
    nodeID: number;
    /**
     * @type {Location}
     */
    location: Location;
    /**
     * @type Location
     */
    keywordLoc: Location;
    /**
     * @type Location | null
     */
    lparenLoc: Location | null;
    /**
     * @type ArgumentsNode | null
     */
    arguments_: ArgumentsNode | null;
    /**
     * @type Location | null
     */
    rparenLoc: Location | null;
    /**
     * Accept a visitor for this node.
     *
     * @param {visitors.Visitor} visitor
     */
    accept(visitor: visitors.Visitor): void;
    /**
     * Returns all child nodes of the current node.
     *
     * @returns {(Node | null)[]} An array of child nodes.
     */
    childNodes(): (Node | null)[];
    /**
     * Compact and return an array of child nodes.
     *
     * @returns {Node[]} An array of compacted child nodes.
     */
    compactChildNodes(): Node[];
    /**
     * Transforms the Node to a JavaScript object.
     *
     * @returns {Object}
     */
    toJSON(): any;
    #private;
}
/**
 * A location in the source code.
 */
export type Location = {
    startOffset: number;
    length: number;
};
/**
 * An encoded Ruby string.
 */
export type RubyString = {
    value: string;
    encoding: string;
    validEncoding: boolean;
};
/**
 * A generic node in the tree.
 */
export type Node = (AliasGlobalVariableNode | AliasMethodNode | AlternationPatternNode | AndNode | ArgumentsNode | ArrayNode | ArrayPatternNode | AssocNode | AssocSplatNode | BackReferenceReadNode | BeginNode | BlockArgumentNode | BlockLocalVariableNode | BlockNode | BlockParameterNode | BlockParametersNode | BreakNode | CallAndWriteNode | CallNode | CallOperatorWriteNode | CallOrWriteNode | CallTargetNode | CapturePatternNode | CaseMatchNode | CaseNode | ClassNode | ClassVariableAndWriteNode | ClassVariableOperatorWriteNode | ClassVariableOrWriteNode | ClassVariableReadNode | ClassVariableTargetNode | ClassVariableWriteNode | ConstantAndWriteNode | ConstantOperatorWriteNode | ConstantOrWriteNode | ConstantPathAndWriteNode | ConstantPathNode | ConstantPathOperatorWriteNode | ConstantPathOrWriteNode | ConstantPathTargetNode | ConstantPathWriteNode | ConstantReadNode | ConstantTargetNode | ConstantWriteNode | DefNode | DefinedNode | ElseNode | EmbeddedStatementsNode | EmbeddedVariableNode | EnsureNode | FalseNode | FindPatternNode | FlipFlopNode | FloatNode | ForNode | ForwardingArgumentsNode | ForwardingParameterNode | ForwardingSuperNode | GlobalVariableAndWriteNode | GlobalVariableOperatorWriteNode | GlobalVariableOrWriteNode | GlobalVariableReadNode | GlobalVariableTargetNode | GlobalVariableWriteNode | HashNode | HashPatternNode | IfNode | ImaginaryNode | ImplicitNode | ImplicitRestNode | InNode | IndexAndWriteNode | IndexOperatorWriteNode | IndexOrWriteNode | IndexTargetNode | InstanceVariableAndWriteNode | InstanceVariableOperatorWriteNode | InstanceVariableOrWriteNode | InstanceVariableReadNode | InstanceVariableTargetNode | InstanceVariableWriteNode | IntegerNode | InterpolatedMatchLastLineNode | InterpolatedRegularExpressionNode | InterpolatedStringNode | InterpolatedSymbolNode | InterpolatedXStringNode | ItLocalVariableReadNode | ItParametersNode | KeywordHashNode | KeywordRestParameterNode | LambdaNode | LocalVariableAndWriteNode | LocalVariableOperatorWriteNode | LocalVariableOrWriteNode | LocalVariableReadNode | LocalVariableTargetNode | LocalVariableWriteNode | MatchLastLineNode | MatchPredicateNode | MatchRequiredNode | MatchWriteNode | MissingNode | ModuleNode | MultiTargetNode | MultiWriteNode | NextNode | NilNode | NoKeywordsParameterNode | NumberedParametersNode | NumberedReferenceReadNode | OptionalKeywordParameterNode | OptionalParameterNode | OrNode | ParametersNode | ParenthesesNode | PinnedExpressionNode | PinnedVariableNode | PostExecutionNode | PreExecutionNode | ProgramNode | RangeNode | RationalNode | RedoNode | RegularExpressionNode | RequiredKeywordParameterNode | RequiredParameterNode | RescueModifierNode | RescueNode | RestParameterNode | RetryNode | ReturnNode | SelfNode | ShareableConstantNode | SingletonClassNode | SourceEncodingNode | SourceFileNode | SourceLineNode | SplatNode | StatementsNode | StringNode | SuperNode | SymbolNode | TrueNode | UndefNode | UnlessNode | UntilNode | WhenNode | WhileNode | XStringNode | YieldNode);
import * as visitors from "./visitor.js";
